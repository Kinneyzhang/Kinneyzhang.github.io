<!DOCTYPE html>
<html lang="zh-CN"><head>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
    <meta name="description" content="Emacs Lisp ç¼–ç¨‹æ€»ç»“ - https://geekinney.com/post/emacs-lisp-learning-note/">
    
    <meta name="msvalidate.01" content="B46311949B856F2A7015F366FB3CE878" />
    <title>Emacs Lisp ç¼–ç¨‹æ€»ç»“</title>
    <link rel="icon" type="image/png" href="/favicon.ico">
    
    <link rel="stylesheet" href="https://geekinney.com/style.min.2bd56458aa287d2080f96e7dbe9a0a5a26417b71557dcb5456ee710e21c940d1.css">
    
    <script type="text/javascript" src="/main.js" defer></script>
    
</head>
<body class="active-animate ">
        <div id="header"><div class="container-header">
    <div id="vars" class="container-vars" style="display: none;">
	{
		"hasFoldAllCodeBlocks": false,
		"svgColor": "#6c757d",
		"en": false,
		"dark": false
	}
</div>
    <h1 class="title">
        
            Emacs Lisp ç¼–ç¨‹æ€»ç»“
            
        
    </h1>

    <div class="container-breadcrumb-nav">
    
    <div class="breadcrumb-nav-bar">
        <div><a href="/"><svg t="1656411084410" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="2954" width="16" height="16"><path d="M947.5 390.6l-377-290c-34.5-26.5-82.6-26.5-117.1 0l-377 290c-14 10.8-16.6 30.9-5.9 44.9 10.8 14 30.9 16.6 44.9 5.9l28.5-21.9V768c0 88.2 71.8 160 160 160h80c35.3 0 64-28.7 64-64V640c0-17.6 14.4-32 32-32h64c17.6 0 32 14.4 32 32v224c0 35.3 28.7 64 64 64h80c88.2 0 160-71.8 160-160V419.4l28.5 21.9c5.8 4.5 12.7 6.6 19.5 6.6 9.6 0 19.1-4.3 25.4-12.5 10.8-13.9 8.2-34-5.8-44.8zM816 768c0 52.9-43.1 96-96 96h-80V640c0-52.9-43.1-96-96-96h-64c-52.9 0-96 43.1-96 96v224h-80c-52.9 0-96-43.1-96-96V370.2l284.5-218.8c11.5-8.8 27.5-8.8 39 0L816 370.2V768z" fill=#6c757d p-id="2955"></path></svg></a></div>
        <div><a href="/nav"><svg t="1656411531924" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="5827" width="16" height="16"><path d="M849.59197473 125.23018519L139.22930586 391.72854662a23.35052669 23.35052669 0 0 0-14.95414244 21.65490745c-0.12257519 9.70384955 5.61801843 18.46795771 14.40255493 22.04306141l318.42928099 129.25528056 119.51057092 320.39047893c3.06437293 8.23295069 10.35758221 13.89182751 18.7335381 14.87242563l2.7170774 0.14300521a22.79893918 22.79893918 0 0 0 21.20546682-15.36272638l259.51158924-729.54564933a23.8612558 23.8612558 0 0 0-5.31158128-24.55584682 22.3290685 22.3290685 0 0 0-23.9021142-5.43415649zM793.65694081 211.64552314l-196.63064161 552.75171747-91.91077952-246.37564122-253.62799211-102.96295445 542.16941324-203.4131218z" p-id="5828" fill=#6c757d></path></svg></a></div>
        <div><a href="/search"><svg t="1656411627509" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="1730" width="14" height="14"><path d="M469.333333 85.333333c211.968 0 384 172.032 384 384s-172.032 384-384 384-384-172.032-384-384 172.032-384 384-384z m0 682.666667c164.992 0 298.666667-133.674667 298.666667-298.666667 0-165.034667-133.674667-298.666667-298.666667-298.666666-165.034667 0-298.666667 133.632-298.666666 298.666666 0 164.992 133.632 298.666667 298.666666 298.666667z m362.026667 3.029333l120.704 120.661334-60.373333 60.373333-120.661334-120.704 60.330667-60.330667z" p-id="1731" fill=#6c757d></path></svg></a></div>
        <div><a href="/posts"><svg t="1656411724198" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="5655" width="12" height="12"><path d="M811.705761 1024H212.294239c-93.1199 0-174.823046-87.570975-174.823046-187.387854V162.322018C37.471193 69.776145 112.604921 0 212.294239 0H596.190595l7.015883 5.93161c111.74388 95.479788 185.857116 170.741078 279.614824 266.093304 29.65805 30.040735 61.165743 62.122454 96.436499 97.393211l7.271006 7.334787v459.859234c-0.063781 99.816879-81.703145 187.387854-174.823046 187.387854zM212.294239 49.94033c-72.391155 0-124.882716 47.261538-124.882716 112.381688v674.290128c0 71.94469 59.507443 137.383743 124.882716 137.383743h599.411522c65.311492 0 124.882716-65.439053 124.882716-137.383743V397.417876c-32.528184-32.464404-61.73977-62.250016-89.356836-90.377328-90.951355-92.418312-163.278729-165.957521-269.601245-257.163999H212.294239z" fill=#6c757d p-id="5656"></path><path d="M936.588477 449.526752h-212.326129c-99.753099 0-187.324073-81.703145-187.324073-174.823046V49.94033a25.002055 25.002055 0 0 1 49.94033 0v224.763376c0 65.311492 65.502834 124.882716 137.383743 124.882716h212.326129a25.002055 25.002055 0 1 1 0 49.94033z" fill=#6c757d p-id="5657"></path></svg></a></div>
        <div><a href="/archive"><svg t="1656411795742" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="7334" width="12" height="12"><path d="M884.224 522.24H504.32V141.824c0-16.896-13.824-30.72-30.72-30.72-120.32 0-233.472 47.616-317.952 134.144S26.112 445.952 29.184 566.784c2.56 114.688 49.152 222.72 131.072 304.128 81.92 81.408 189.952 128 304.64 130.56h10.24c117.76 0 227.84-45.568 312.32-128.512 86.528-85.504 133.632-199.68 132.608-321.024-0.512-2.048-1.536-29.696-35.84-29.696z m-140.288 307.712c-74.752 73.728-173.056 112.64-277.504 110.592-205.824-4.608-370.688-169.472-375.296-374.784-3.072-104.448 35.84-202.752 108.544-277.504 65.536-67.072 151.552-107.52 243.712-114.688v378.88c0 16.896 13.824 30.72 30.72 30.72 129.024 0 311.296 0 382.976 0.512-6.144 93.184-46.08 179.712-113.152 246.272z" fill=#6c757d p-id="7335"></path><path d="M603.136 11.264c-8.192-0.512-15.872 3.072-22.016 8.704-5.632 5.632-9.216 13.824-9.216 22.016v378.88c0 16.896 13.824 30.72 30.72 30.72h378.88c16.896 0 30.72-13.824 30.72-30.72 0-223.744-183.808-407.552-409.088-409.6z m30.208 378.88V74.24c167.424 16.384 301.056 150.016 315.904 315.904h-315.904z" fill=#6c757d p-id="7336"></path></svg></a></div>
        <div id="light-dark" style="cursor: pointer;"><a><svg t="1656411842215" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="5086" width="12" height="12"><path d="M1007.492874 384.513055c-8.795694-34.58307-21.189627-67.666874-36.682043-99.05151-2.698679-5.397358-10.894667-3.498287-10.894666 2.598728v0.299853c0 32.484098-6.896624 63.868734-19.890263 92.554691-10.694764 23.488501-25.487523 45.077933-43.978471 64.068635-41.779547 42.679107-99.05151 66.967217-158.722299 67.26707-61.869712 0.299853-119.941284-24.188159-162.920244-68.966238-40.280281-41.979449-62.56937-98.251902-62.269516-156.323473 0.399804-59.270984 23.588452-114.94373 65.567901-156.823229 19.59041-19.59041 42.179351-35.082826 66.667364-46.077443C672.956643 71.166451 704.041426 64.469729 736.125719 64.469729h1.299364c6.097015 0 8.096037-8.096037 2.598728-10.794715C708.739126 37.982696 675.655322 25.488812 641.172203 16.493216 599.492607 5.598549 555.714038-0.098662 510.536154 0.001289 222.37722 0.700947-7.41029 237.38508 0.185992 525.444064c7.096526 271.667008 225.889418 490.559851 497.456474 497.856279 287.559228 7.796183 524.14341-220.891864 525.842579-508.551044 0.299853-44.977981-5.297407-88.656599-15.992171-130.236244z m-83.15929 301.552378c-22.588942 53.27392-54.873137 101.250434-95.953027 142.330323-41.179841 41.179841-89.056403 73.464036-142.330324 95.953027-55.172991 23.288599-113.744317 35.182777-174.314666 35.182777s-119.141675-11.794226-174.314666-35.182777c-53.27392-22.588942-101.250434-54.873137-142.330323-95.953027-41.179841-41.179841-73.464036-89.056403-95.953027-142.330323C75.749001 630.892442 63.954774 572.221164 63.954774 511.750767s11.794226-119.141675 35.182777-174.314666c22.588942-53.27392 54.873137-101.250434 95.953027-142.330323 41.179841-41.179841 89.056403-73.464036 142.330323-95.953027C392.593892 75.7642 451.26517 63.969974 511.735567 63.969974c13.99315 0 27.886348 0.599706 41.679596 1.89907C489.246577 118.643209 448.266638 198.704016 448.266638 288.360126c0 159.022152 128.836929 287.859081 287.859081 287.859081 89.156354 0 168.817357-40.580134 221.691473-104.149015 1.099462 13.09359 1.699168 26.387082 1.699168 39.680575 0 60.470397-11.794226 119.141675-35.182776 174.314666z" p-id="5087" fill=#6c757d></path></svg></a></div>
        
    </div>

    
</div>

            <div id="toc">ğŸ“œ</div>
        
    
    
</div>
</div>
        <div id="content">












<div class="container-main 
     container-page 
">

    <div class="desc">
        
        <span>
            
            <svg t="1656736000388" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="7409" width="12" height="12"><path d="M524.885333 338.986667L200.362667 663.466667c-17.28 15.274667-27.989333 36.693333-29.696 56.234666v133.76l130.730666 0.085334c22.784-1.621333 43.989333-12.245333 61.013334-31.701334l322.688-322.645333-160.213334-160.213333z m60.373334-60.330667l160.170666 160.213333 102.144-102.144a19.712 19.712 0 0 0 0-27.861333L715.093333 176.426667a19.456 19.456 0 0 0-27.605333 0L585.258667 278.613333zM701.312 85.333333c27.946667 0 54.741333 11.136 74.282667 30.848l132.309333 132.309334a105.045333 105.045333 0 0 1 0 148.565333L424.874667 879.957333c-29.824 34.346667-72.106667 55.466667-120.448 58.794667H85.333333v-42.666667l0.128-179.84c3.626667-44.970667 24.576-86.826667 56.448-114.944l485.12-485.034666A104.789333 104.789333 0 0 1 701.269333 85.333333z" p-id="7410" fill="#adb5bd"></path></svg>
            2019-11-12&nbsp;
        </span>
        <span>
            
            <svg t="1656737270708" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="23838" width="11" height="11"><path d="M824.264 95.36c0-23.859 25.043-44.16 48.902-44.16s49.714 20.301 49.714 44.16v190.08c0 23.859-19.054 52.868-42.913 52.868h-190.08c-23.859 0-46.696-25.96-46.696-49.819s22.55-46.249 46.409-46.249h82.025C702.344 175.534 610.22 155.853 512 155.853c-206.775 0-360.398 149.372-360.398 356.147 0 206.775 153.623 358.23 360.398 358.23 206.775 0 357.467-151.455 357.467-358.23 0-23.859 23.634-50.706 53.413-50.706 29.78 0 49.92 26.847 49.92 50.706 0 254.493-206.307 460.8-460.8 460.8-254.493 0-460.8-206.307-460.8-460.8C51.2 257.507 257.507 51.2 512 51.2c122.4 0 226.684 33.296 312.264 117.369 0.358 0.351 0.358-24.052 0-73.209z" p-id="23839" fill="#adb5bd"></path></svg>
            2022-10-13&nbsp;&nbsp;&nbsp;
        </span>
        <span>
            
            <svg t="1656737548689" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="33866" width="12" height="12"><path d="M832.038608 64.662657H192.030028C121.255125 64.662657 63.940169 121.98845 63.940169 192.694717v446.793671C63.940169 710.205493 121.255125 767.643272 192.030028 767.643272h133.353183a63.940169 63.940169 0 0 1 55.219742 31.576328l76.099638 129.83828c12.358154 21.093031 33.790754 31.626903 55.216129 31.626903s42.832688-10.544709 55.198067-31.619678l76.222461-129.870792a63.940169 63.940169 0 0 1 55.212517-31.551041h133.54103c70.576219 0 127.732228-57.289669 127.732227-127.800865V192.391272C959.825022 121.85479 902.643727 64.662657 832.038608 64.662657zM895.884854 639.842407A63.85347 63.85347 0 0 1 832.092795 703.703103h-133.54103a127.753903 127.753903 0 0 0-110.349172 63.09847l-76.222461 129.856342a0.274545 0.274545 0 0 1 0-0.050574h-0.032512s-0.021675 0.061411-0.032512 0.061412l-76.1466-129.85273A127.804477 127.804477 0 0 0 325.383211 703.703103H192.030028A64.207489 64.207489 0 0 1 127.880338 639.488388V192.694717A64.102729 64.102729 0 0 1 192.030028 128.602826h640.00858A63.799284 63.799284 0 0 1 895.884854 192.391272v447.451135z" fill="#adb5bd" p-id="33867"></path><path d="M608.154093 288.092004A31.970084 31.970084 0 0 0 576.184009 320.062089v160.078006l-134.650049-179.278119A31.970084 31.970084 0 0 0 384.002258 320.062089v255.760676a31.970084 31.970084 0 0 0 63.940169 0v-159.958796l134.650048 179.274507a31.970084 31.970084 0 0 0 57.531703-19.200113V320.062089a31.970084 31.970084 0 0 0-31.970085-31.970085z" fill="#adb5bd" p-id="33868"></path></svg>
            11895 å­—</span>&nbsp;
        <span>
            
            <svg t="1656737462334" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="32892" width="12" height="12"><path d="M512 74.666667C270.933333 74.666667 74.666667 270.933333 74.666667 512S270.933333 949.333333 512 949.333333 949.333333 753.066667 949.333333 512 753.066667 74.666667 512 74.666667z m0 810.666666c-204.8 0-373.333333-168.533333-373.333333-373.333333S307.2 138.666667 512 138.666667 885.333333 307.2 885.333333 512 716.8 885.333333 512 885.333333z" p-id="32893" fill="#adb5bd"></path><path d="M695.466667 567.466667l-151.466667-70.4V277.333333c0-17.066667-14.933333-32-32-32s-32 14.933333-32 32v238.933334c0 12.8 6.4 23.466667 19.2 29.866666l170.666667 81.066667c4.266667 2.133333 8.533333 2.133333 12.8 2.133333 12.8 0 23.466667-6.4 29.866666-19.2 6.4-14.933333 0-34.133333-17.066666-42.666666z" p-id="32894" fill="#adb5bd"></path></svg>
            24 åˆ†é’Ÿ</span><div class="container-ctgtag">
	<div class="taxonomy">
		
		<div class="ctg">
			
			
			<a href="/categories/happy-hacking-emacs">Happy Hacking Emacs</a>
			
		</div>
		<div class="tag">
			
			 - 
			
			<a href="/tags/elisp">elisp</a>
			
			<a href="/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0">å­¦ä¹ ç¬”è®°</a>
			
		</div>
	</div>
</div>
    </div>
    
    <div class="toc">
        
        <div class="page-operation">
            <div><a href="#"><img src="/imgs/icons/arrow-up-circle.svg" alt=""></a></div>
            <div><a href="https://geekinney.com/post/thinking-about-anxiety/"><img src="/imgs/icons/arrow-left-circle.svg" alt=""></a></div>
            <div><a href="https://geekinney.com/post/reading-notes-of-getting-things-done-one/"><img src="/imgs/icons/arrow-right-circle.svg" alt=""></a></div>
        </div>
        
        <nav id="TableOfContents">
  <ul>
    <li><a href="#æ¦‚è§ˆ">æ¦‚è§ˆ</a>
      <ul>
        <li><a href="#è¿è¡Œemacs-lispçš„å‡ ç§æ–¹å¼">è¿è¡Œemacs-lispçš„å‡ ç§æ–¹å¼</a></li>
        <li><a href="#åˆ›å»ºå‘½ä»¤interactiveå‡½æ•°">åˆ›å»ºå‘½ä»¤ï¼ˆinteractiveå‡½æ•°ï¼‰</a></li>
        <li><a href="#emacsæ¢ç´¢">emacsæ¢ç´¢</a></li>
      </ul>
    </li>
    <li><a href="#elispç¼–ç¨‹çš„åŸºæœ¬è®¾ç½®">elispç¼–ç¨‹çš„åŸºæœ¬è®¾ç½®</a></li>
    <li><a href="#åŸºæœ¬è¿ç®—">åŸºæœ¬è¿ç®—</a>
      <ul>
        <li><a href="#ç®—æœ¯">ç®—æœ¯</a></li>
        <li><a href="#æ¯”è¾ƒ">æ¯”è¾ƒ</a></li>
        <li><a href="#åˆ—è¡¨">åˆ—è¡¨</a></li>
      </ul>
    </li>
    <li><a href="#ç±»å‹åˆ¤æ–­å’Œliterals">ç±»å‹åˆ¤æ–­å’ŒLiterals</a>
      <ul>
        <li><a href="#emacs-literals">Emacs Literals</a></li>
        <li><a href="#åŸºæœ¬ç±»å‹åˆ¤æ–­">åŸºæœ¬ç±»å‹åˆ¤æ–­</a></li>
        <li><a href="#è·å–å¯¹è±¡ç±»å‹">è·å–å¯¹è±¡ç±»å‹</a></li>
      </ul>
    </li>
    <li><a href="#å˜é‡å®šä¹‰">å˜é‡å®šä¹‰</a></li>
    <li><a href="#å‡½æ•°å®šä¹‰">å‡½æ•°å®šä¹‰</a>
      <ul>
        <li><a href="#å®šä¹‰ç®€å•å‡½æ•°">å®šä¹‰ç®€å•å‡½æ•°</a></li>
        <li><a href="#åŒ¿åå‡½æ•°lambdaå‡½æ•°">åŒ¿åå‡½æ•°/Lambdaå‡½æ•°</a></li>
        <li><a href="#å‡½æ•°ä½œä¸ºå‚æ•°">å‡½æ•°ä½œä¸ºå‚æ•°</a></li>
        <li><a href="#å¤šå‚å‡½æ•°">å¤šå‚å‡½æ•°</a></li>
        <li><a href="#å¯é€‰å‚æ•°å‡½æ•°">å¯é€‰å‚æ•°å‡½æ•°</a></li>
        <li><a href="#å«å±æ€§åˆ—è¡¨å‚æ•°å‡½æ•°">å«å±æ€§åˆ—è¡¨å‚æ•°å‡½æ•°</a></li>
        <li><a href="#closures">Closures</a></li>
      </ul>
    </li>
    <li><a href="#åˆ—è¡¨æ“ä½œ">åˆ—è¡¨æ“ä½œ</a></li>
    <li><a href="#å…³è”åˆ—è¡¨å’Œå±æ€§åˆ—è¡¨">å…³è”åˆ—è¡¨å’Œå±æ€§åˆ—è¡¨</a>
      <ul>
        <li><a href="#æ¦‚è§ˆ-1">æ¦‚è§ˆ</a></li>
        <li><a href="#å…³è”åˆ—è¡¨alist">å…³è”åˆ—è¡¨/Alist</a></li>
        <li><a href="#å±æ€§åˆ—è¡¨">å±æ€§åˆ—è¡¨</a></li>
        <li><a href="#è½¬æ¢alistæˆplistå’Œvice-versa">è½¬æ¢AlistæˆPlistå’Œvice-versa</a></li>
      </ul>
    </li>
    <li><a href="#å­—ç¬¦ä¸²">å­—ç¬¦ä¸²</a></li>
    <li><a href="#ç¬¦å·">ç¬¦å·</a></li>
    <li><a href="#ç±»å‹è½¬æ¢">ç±»å‹è½¬æ¢</a></li>
    <li><a href="#æ±‚å€¼">æ±‚å€¼</a></li>
    <li><a href="#defalias">Defalias</a></li>
    <li><a href="#æ§åˆ¶ç»“æ„">æ§åˆ¶ç»“æ„</a>
      <ul>
        <li><a href="#conditional-statement">Conditional Statement</a></li>
        <li><a href="#cond---case-switch">Cond - Case Switch</a></li>
        <li><a href="#cl-case---case-switch">CL-Case - Case Switch</a></li>
        <li><a href="#å¾ªç¯">å¾ªç¯</a></li>
        <li><a href="#å‡½æ•°å¼ç¼–ç¨‹">å‡½æ•°å¼ç¼–ç¨‹</a></li>
      </ul>
    </li>
    <li><a href="#structures">Structures</a></li>
  </ul>

  <ul>
    <li><a href="#quasi-quote">Quasi-quote</a></li>
    <li><a href="#å®">å®</a></li>
  </ul>

  <ul>
    <li><a href="#emacsæœ¯è¯­">Emacsæœ¯è¯­</a></li>
    <li><a href="#emacs-api-1">Emacs API</a></li>
    <li><a href="#buffers">Buffers</a>
      <ul>
        <li><a href="#buffer-attributes">Buffer Attributes</a></li>
        <li><a href="#buffer-mode">Buffer Mode</a></li>
        <li><a href="#get-buffer-contents--selection--line">Get Buffer Contents / Selection / Line</a></li>
        <li><a href="#search-and-replace-in-the-entire-buffer">Search and Replace in the entire Buffer</a></li>
      </ul>
    </li>
    <li><a href="#point-region-line-and-buffer">Point, Region, Line and Buffer</a>
      <ul>
        <li><a href="#point">Point</a></li>
        <li><a href="#thing-at-point-api">Thing at Point API</a></li>
      </ul>
    </li>
    <li><a href="#message--output">Message / Output</a></li>
    <li><a href="#files-directories-and-path">Files, Directories and Path</a>
      <ul>
        <li><a href="#basic-functions">Basic Functions</a></li>
        <li><a href="#file-name-components">File Name Components</a></li>
        <li><a href="#read--write-file-to-a-string">Read / Write file to a string</a></li>
      </ul>
    </li>
    <li><a href="#window-functions">Window Functions</a>
      <ul>
        <li><a href="#basic-window-functions">Basic Window Functions</a></li>
        <li><a href="#manipulate-buffer-in-another-window">Manipulate Buffer in Another Window</a></li>
        <li><a href="#window-configuration">Window Configuration</a></li>
      </ul>
    </li>
    <li><a href="#os-interface">OS Interface</a>
      <ul>
        <li><a href="#find-the-current-operating-system">Find the current operating system</a></li>
        <li><a href="#date-and-time">Date and Time</a></li>
        <li><a href="#call-external-commands-or-apps">Call External Commands or Apps</a></li>
        <li><a href="#environment-variables">Environment Variables</a></li>
        <li><a href="#process-management">Process Management</a></li>
      </ul>
    </li>
    <li><a href="#interfaces">Interfaces</a>
      <ul>
        <li><a href="#creating-quick-access-menu">Creating Quick Access Menu</a></li>
        <li><a href="#add-icons-to-toolbar">Add Icons to toolbar</a></li>
      </ul>
    </li>
    <li><a href="#timer">Timer</a>
      <ul>
        <li><a href="#run-with-timer">run-with-timer</a></li>
      </ul>
    </li>
    <li><a href="#emacs-modes">Emacs Modes</a>
      <ul>
        <li><a href="#mode-association-with-files">Mode Association with Files</a></li>
        <li><a href="#lisp-routines-to-introspect-modes">Lisp Routines to introspect modes??</a></li>
        <li><a href="#mode-specific-key-bindings">Mode Specific Key Bindings</a></li>
      </ul>
    </li>
    <li><a href="#special-variables">Special Variables</a></li>
    <li><a href="#network">Network</a></li>
  </ul>

  <ul>
    <li><a href="#emacs-regex">Emacs Regex</a></li>
    <li><a href="#regex-commands">Regex Commands</a></li>
    <li><a href="#regex-functions">Regex Functions</a>
      <ul>
        <li><a href="#match-string">match-string</a></li>
        <li><a href="#match-end">match-end</a></li>
        <li><a href="#match-beginning">match-beginning</a></li>
        <li><a href="#re-search">re-search</a></li>
        <li><a href="#re-search-forward">re-search-forward</a></li>
        <li><a href="#replace-string-in-regexp">replace-string-in-regexp</a></li>
        <li><a href="#replace-string">replace-string</a></li>
      </ul>
    </li>
    <li><a href="#build-regex-interactively">Build regex interactively</a></li>
    <li><a href="#emacs-regex-rx-notation">Emacs Regex rx-notation</a></li>
  </ul>
</nav>
    </div>

    <div class='content  content '>
        <h1 id="lispä»‹ç»">lispä»‹ç»</h1>
<p>Lispï¼ˆå†å²ä¸Šæ‹¼å†™ä¸ºLISPï¼‰æ˜¯å…·æœ‰æ‚ ä¹…å†å²çš„è®¡ç®—æœºç¼–ç¨‹è¯­è¨€å®¶æ—ï¼Œæœ‰ç‹¬ç‰¹å’Œå®Œå…¨æ‹¬å·çš„å‰ç¼€ç¬¦å·è¡¨ç¤ºæ³•ã€‚èµ·æºäºå…¬å…ƒ1958å¹´ï¼Œæ˜¯ç°ä»Šç¬¬äºŒæ‚ ä¹…è€Œä»å¹¿æ³›ä½¿ç”¨çš„é«˜ç«¯ç¼–ç¨‹è¯­è¨€ã€‚åªæœ‰FORTRANç¼–ç¨‹è¯­è¨€æ¯”å®ƒæ›´æ—©ä¸€å¹´ã€‚Lispç¼–ç¨‹è¯­æ—å·²ç»æ¼”å˜å‡ºè®¸å¤šç§æ–¹è¨€ã€‚ç°ä»£æœ€è‘—åçš„é€šç”¨ç¼–ç¨‹è¯­ç§æ˜¯Clojureã€Common Lispå’ŒSchemeã€‚</p>
<p>Lispæœ€åˆåˆ›å»ºæ—¶å—åˆ°é˜¿éš†ä½Â·é‚±å¥‡çš„lambdaæ¼”ç®—çš„å½±å“ï¼Œç”¨æ¥ä½œä¸ºè®¡ç®—æœºç¨‹åºå®ç”¨çš„æ•°å­¦è¡¨è¾¾ã€‚å› ä¸ºæ˜¯æ—©æœŸçš„é«˜ç«¯ç¼–ç¨‹è¯­è¨€ä¹‹ä¸€ï¼Œå®ƒå¾ˆå¿«æˆä¸ºäººå·¥æ™ºèƒ½ç ”ç©¶ä¸­æœ€å—æ¬¢è¿çš„ç¼–ç¨‹è¯­è¨€ã€‚åœ¨è®¡ç®—æœºç§‘å­¦é¢†åŸŸï¼ŒLispå¼€åˆ›äº†è®¸å¤šå…ˆé©±æ¦‚å¿µï¼ŒåŒ…æ‹¬ï¼šæ ‘ç»“æ„ã€è‡ªåŠ¨å­˜å‚¨å™¨ç®¡ç†ã€åŠ¨æ€ç±»å‹ã€æ¡ä»¶è¡¨è¾¾å¼ã€é«˜ç«¯å‡½æ•°ã€é€’å½’ã€è‡ªä¸»ï¼ˆself-hostingï¼‰ç¼–è¯‘å™¨ã€è¯»å–ï¹£æ±‚å€¼ï¹£è¾“å‡ºå¾ªç¯ï¼ˆè‹±è¯­ï¼šRead-Eval-Print Loopï¼ŒREPLï¼‰ã€‚</p>
<p>&ldquo;LISP&quot;åç§°æºè‡ªâ€œåˆ—è¡¨å¤„ç†å™¨â€ï¼ˆè‹±è¯­ï¼šLISt Processorï¼‰çš„ç¼©å†™ã€‚åˆ—è¡¨æ˜¯Lispçš„ä¸»è¦æ•°æ®ç»“æ„ä¹‹ä¸€ï¼ŒLispç¼–ç¨‹ä»£ç ä¹ŸåŒæ ·ç”±åˆ—è¡¨ç»„æˆã€‚å› æ­¤ï¼ŒLispç¨‹åºå¯ä»¥æŠŠæºä»£ç å½“ä½œæ•°æ®ç»“æ„è¿›è¡Œæ“ä½œï¼Œè€Œä½¿ç”¨å…¶ä¸­çš„å®ç³»ç»Ÿï¼Œå¼€å‘äººå‘˜å¯å°†è‡ªå·±å®šä¹‰çš„æ–°è¯­æ³•æˆ–é¢†åŸŸä¸“ç”¨çš„è¯­è¨€ï¼ŒåµŒå…¥åœ¨Lispç¼–ç¨‹ä¸­ã€‚</p>
<p>ä»£ç å’Œæ•°æ®çš„å¯äº’æ¢æ€§ä¸ºLispæä¾›äº†ç«‹å³å¯è¯†åˆ«çš„è¯­æ³•ã€‚æ‰€æœ‰çš„Lispç¨‹åºä»£ç éƒ½å†™ä¸ºS-è¡¨è¾¾å¼æˆ–ä»¥æ‹¬å·è¡¨ç¤ºçš„åˆ—è¡¨ã€‚å‡½æ•°è°ƒç”¨æˆ–è¯­ä¹‰å½¢å¼ä¹ŸåŒæ ·å†™æˆåˆ—è¡¨ï¼Œé¦–å…ˆæ˜¯å‡½æ•°æˆ–æ“ä½œç¬¦çš„åç§°ï¼Œç„¶åæ¥ç€æ˜¯ä¸€æˆ–å¤šä¸ªå‚æ•°ï¼šä¾‹å¦‚ï¼Œå–ä¸‰ä¸ªå‚æ•°çš„å‡½æ•°få³ä¸ºï¼ˆf arg1 arg2 arg3ï¼‰ã€‚</p>
<p>Lispè¯­è¨€çš„ä¸»è¦ç°ä»£ç‰ˆæœ¬åŒ…æ‹¬Common Lisp, Schemeï¼ŒRacketä»¥åŠClojureã€‚1980å¹´ä»£ç›–ä¼ŠÂ·å²æå°”äºŒä¸–ç¼–å†™äº†Common Lispè¯•å›¾è¿›è¡Œæ ‡å‡†åŒ–ï¼Œè¿™ä¸ªæ ‡å‡†è¢«å¤§å¤šæ•°è§£é‡Šå™¨å’Œç¼–è¯‘å™¨æ‰€æ¥å—ã€‚è¿˜æœ‰ä¸€ç§æ˜¯ç¼–è¾‘å™¨Emacsæ‰€æ´¾ç”Ÿå‡ºæ¥çš„Emacs Lispï¼ˆè€ŒEmacsæ­£æ˜¯ç”¨Lispä½œä¸ºæ‰©å±•è¯­è¨€è¿›è¡ŒåŠŸèƒ½æ‰©å±•ï¼‰éå¸¸æµè¡Œï¼Œå¹¶åˆ›å»ºäº†è‡ªå·±çš„æ ‡å‡†ã€‚</p>
<h1 id="elisp">Elisp</h1>
<h2 id="æ¦‚è§ˆ">æ¦‚è§ˆ</h2>
<h3 id="è¿è¡Œemacs-lispçš„å‡ ç§æ–¹å¼">è¿è¡Œemacs-lispçš„å‡ ç§æ–¹å¼</h3>
<table>
<colgroup>
<col  class="org-left">
<col  class="org-left">
<col  class="org-left">
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">key</th>
<th scope="col" class="org-left">command</th>
<th scope="col" class="org-left">description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">`C-x C-e`</td>
<td class="org-left">`eval-last-sexp`</td>
<td class="org-left">åœ¨Sè¡¨è¾¾å¼ç»“å°¾è¿è¡Œï¼Œåœ¨minibufferæ˜¾ç¤ºç»“æœ</td>
</tr>
<tr>
<td class="org-left">`C-j`</td>
<td class="org-left">`eval-print-last-sexp`</td>
<td class="org-left">åœ¨Sè¡¨è¾¾å¼ç»“å°¾è¿è¡Œï¼Œæ‰“å°è¿è¡Œç»“æœ</td>
</tr>
<tr>
<td class="org-left">`M-:`</td>
<td class="org-left">`eval-expression`</td>
<td class="org-left">åœ¨minibufferè¾“å…¥å‘½ä»¤å¹¶æ‰§è¡Œ</td>
</tr>
<tr>
<td class="org-left">`M-x ielm`</td>
<td class="org-left">`ielm`</td>
<td class="org-left">ä½¿ç”¨IELMè§£é‡Šå™¨è¿è¡Œä»£ç </td>
</tr>
</tbody>
</table>
<h3 id="åˆ›å»ºå‘½ä»¤interactiveå‡½æ•°">åˆ›å»ºå‘½ä»¤ï¼ˆinteractiveå‡½æ•°ï¼‰</h3>
<pre><code>;; example
(defun buffer/insert-filename ()
  &quot;Insert file path of current buffer at current point&quot;
  (interactive)
  (insert (buffer-file-name (current-buffer))))
</code></pre>
<h3 id="emacsæ¢ç´¢">emacsæ¢ç´¢</h3>
<table>
<colgroup>
<col  class="org-left">
<col  class="org-left">
<col  class="org-left">
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">key</th>
<th scope="col" class="org-left">command</th>
<th scope="col" class="org-left">description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">`C-h k`</td>
<td class="org-left">`describe-key`</td>
<td class="org-left">è¿è¡Œå‘½ä»¤åï¼Œç»§ç»­æŒ‰é”®ï¼ŒæŸ¥çœ‹æ­¤æ—¶æŒ‰é”®ç»‘å®šçš„å‡½æ•°</td>
</tr>
<tr>
<td class="org-left">`C-h b`</td>
<td class="org-left">`describe-bindings`</td>
<td class="org-left">åœ¨\*Help\*ç•Œé¢æœç´¢ `Major Mode Bindings:` å¯ä»¥æŸ¥çœ‹æ‰€æœ‰ä¸å½“å‰major modeç›¸å…³çš„æŒ‰é”®ã€‚</td>
</tr>
<tr>
<td class="org-left">`C-h f`</td>
<td class="org-left">`describe-function`</td>
<td class="org-left">æŸ¥çœ‹å‡½æ•°æ–‡æ¡£åŠè¯¦ç»†ä»£ç </td>
</tr>
</tbody>
</table>
<h2 id="elispç¼–ç¨‹çš„åŸºæœ¬è®¾ç½®">elispç¼–ç¨‹çš„åŸºæœ¬è®¾ç½®</h2>
<p>ä¸‰ä¸ªæœ‰ç”¨çš„pcakage:</p>
<ul>
<li>rainbow-delimiters: ä¸åŒé¢œè‰²åŒºåˆ†ä¸åŒå±‚çº§çš„æ‹¬å·</li>
<li>paredit: æ£€æŸ¥æ‹¬å·åŒ¹é…</li>
<li>company: elispä»£ç è¡¥å…¨</li>
</ul>
<h2 id="åŸºæœ¬è¿ç®—">åŸºæœ¬è¿ç®—</h2>
<h3 id="ç®—æœ¯">ç®—æœ¯</h3>
<pre><code>ELISP&gt; (+ 20 30)
50
ELISP&gt; (- 100 80)
20
ELISP&gt; (+ 1 2 3 4 5 6)
21
ELISP&gt; (* 1 2 3 4 5 6)
720
ELISP&gt; (/ 1 100)
0

ELISP&gt; (&gt; 10 1) ;; ?? 10 &gt; 1
t
ELISP&gt; (&lt; 2 8) ;; ?? 2 &lt; 8
t
ELISP&gt; (&lt; 8 2) ;; ?? 8 &lt; 2
nil

ELISP&gt; (= 2 2)
t
ELISP&gt; (= 2 4)
nil

ELISP&gt; (/= 2 2)
nil
ELISP&gt; (exp -1)
0.36787944117144233
ELISP&gt; (log 10)
2.302585092994046
ELISP&gt; (sin pi)
1.2246467991473532e-16
ELISP&gt; (cos pi)
-1.0
ELISP&gt; (tan (/ pi 2))
1.633123935319537e+16
ELISP&gt;
</code></pre>
<h3 id="æ¯”è¾ƒ">æ¯”è¾ƒ</h3>
<pre><code>;;;; Compare Numbers
ELISP&gt; (= 2 (+ 1 1))
t

;;; Compare Symbols and Numbers
ELISP&gt; (eq 1 1)
t
ELISP&gt; (eq 1 2)
nil
ELISP&gt;

ELISP&gt; (eq 'x 'x)
t
ELISP&gt;

;;; Compare Elements of a List
ELISP&gt; (equal (list 1 2 3 4) (list 1 2 3 4))
t

;;; Compare Strings
ELISP&gt; (string= &quot;hello&quot; &quot;hello&quot;)
t
</code></pre>
<h3 id="åˆ—è¡¨">åˆ—è¡¨</h3>
<pre><code>ELISP&gt; '(10 20 30 40)
(10 20 30 40)

ELISP&gt; '(10 203 40 &quot;hello&quot; () (&quot;empty&quot; 65))
(10 203 40 &quot;hello&quot; nil
    (&quot;empty&quot; 65))
</code></pre>
<h2 id="ç±»å‹åˆ¤æ–­å’Œliterals">ç±»å‹åˆ¤æ–­å’ŒLiterals</h2>
<h3 id="emacs-literals">Emacs Literals</h3>
<pre><code>;;; Numbers
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
ELISP&gt; 1e3
1000.0

;;; String
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
ELISP&gt; &quot;Hello World Emacs Literals&quot;
&quot;Hello World Emacs Literals&quot;
ELISP&gt;

;;; Symbol
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

ELISP&gt; 'this-a-symbol
this-a-symbol

ELISP&gt; 'vector-&gt;list
vector-&gt;list

ELISP&gt; 'symbol?
symbol\?
ELISP&gt;

;; Boolean t and nil
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
ELISP&gt; t
t
ELISP&gt; nil
nil
ELISP&gt;

 ;;; Everything that is not &quot;nil&quot; is true:
 ;;-----------------------------------------
ELISP&gt; (if t &quot;It is true (not nil)&quot; &quot;It is false (it is nil)&quot;)
&quot;It is true (not nil)&quot;
ELISP&gt;
ELISP&gt; (if 100e3 &quot;It is true (not nil)&quot; &quot;It is false (it is nil)&quot;)
&quot;It is true (not nil)&quot;
ELISP&gt; (if '(a b c d)  &quot;It is true (not nil)&quot; &quot;It is false (it is nil)&quot;)
&quot;It is true (not nil)&quot;
ELISP&gt;

ELISP&gt; (if nil  &quot;It is true (not nil)&quot; &quot;It is false (it is nil)&quot;)
&quot;It is false (it is nil)&quot;
ELISP&gt;

;;; Pair / Cons Cell
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
ELISP&gt; '(a . b)
(a . b)

ELISP&gt; '(a . 2999)
(a . 2999)

;;; List
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
ELISP&gt; '(1 2 3 (3 4) (5 6 (+ 3 4)) 10 'a 'b &quot;hello&quot; )
(1 2 3
   (3 4)
   (5 6
      (+ 3 4))
   10 'a 'b &quot;hello&quot;)

ELISP&gt; '(+ 1 2 3 4 5)
(+ 1 2 3 4 5)

ELISP&gt; '(cos 10)
(cos 10)

;;; Vectors
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
ELISP&gt; [1 2 3 4 (+ 1 2 3 54)]
[1 2 3 4
   (+ 1 2 3 54)]
</code></pre>
<h3 id="åŸºæœ¬ç±»å‹åˆ¤æ–­">åŸºæœ¬ç±»å‹åˆ¤æ–­</h3>
<table>
<colgroup>
<col  class="org-left">
<col  class="org-left">
<col  class="org-left">
<col  class="org-left">
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Type</th>
<th scope="col" class="org-left">Predicate</th>
<th scope="col" class="org-left">Literal</th>
<th scope="col" class="org-left">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">Nil</td>
<td class="org-left">null</td>
<td class="org-left">nil '()</td>
<td class="org-left">Test if argument is nil</td>
</tr>
<tr>
<td class="org-left">Numbers</td>
<td class="org-left">numberp</td>
<td class="org-left">100, 200e3</td>
<td class="org-left">Test if it is number.</td>
</tr>
<tr>
<td class="org-left">String</td>
<td class="org-left">stringp</td>
<td class="org-left">"hello"</td>
<td class="org-left">Test if it is string</td>
</tr>
<tr>
<td class="org-left">Symbol</td>
<td class="org-left">symbolp</td>
<td class="org-left">'sym :keyworkd</td>
<td class="org-left">Test if it is a symbol.</td>
</tr>
<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
</tr>
<tr>
<td class="org-left">Atom</td>
<td class="org-left">atom</td>
<td class="org-left">'x "h" :key 200</td>
<td class="org-left">Everything that is not a list or pair is an atom.</td>
</tr>
<tr>
<td class="org-left">List</td>
<td class="org-left">listp</td>
<td class="org-left">'(1 2 x y)</td>
<td class="org-left">Test if it is a list</td>
</tr>
<tr>
<td class="org-left">Pair</td>
<td class="org-left">consp</td>
<td class="org-left">'(a . 200)</td>
<td class="org-left">Test if it is a pair (cons cell)</td>
</tr>
<tr>
<td class="org-left">Vector</td>
<td class="org-left">vectorp</td>
<td class="org-left">[1 200 'sym]</td>
<td class="org-left">Test if it is a vector</td>
</tr>
</tbody>
</table>
<table>
<colgroup>
<col  class="org-left">
<col  class="org-left">
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Object</th>
<th scope="col" class="org-left">Predicate</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">Buffer</td>
<td class="org-left">bufferp</td>
</tr>
<tr>
<td class="org-left">Window</td>
<td class="org-left">windowp</td>
</tr>
<tr>
<td class="org-left">Frame</td>
<td class="org-left">framep</td>
</tr>
<tr>
<td class="org-left">Process</td>
<td class="org-left">processp</td>
</tr>
</tbody>
</table>
<pre><code>ELISP&gt; (null nil)
t
ELISP&gt;
ELISP&gt; (null '())
t

ELISP&gt; (null 10)
nil

ELISP&gt; (atom 10)
t
ELISP&gt; (atom '(a . b))
nil
ELISP&gt; (atom &quot;hello world&quot;)
t
ELISP&gt;

ELISP&gt; (bufferp (current-buffer))
t
ELISP&gt; (bufferp (selected-window))
nil
ELISP&gt; (windowp (selected-window))
t
ELISP&gt;
</code></pre>
<h3 id="è·å–å¯¹è±¡ç±»å‹">è·å–å¯¹è±¡ç±»å‹</h3>
<pre><code>ELISP&gt; (type-of (current-buffer))
buffer
ELISP&gt;
ELISP&gt; (type-of (selected-window))
window
ELISP&gt;

ELISP&gt; (equal 'buffer (type-of (current-buffer)))
t
ELISP&gt; (equal 'buffer (type-of (selected-window)))
nil
ELISP&gt;
</code></pre>
<h2 id="å˜é‡å®šä¹‰">å˜é‡å®šä¹‰</h2>
<pre><code>;;; Constants
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

ELISP&gt; (defconst zsh-shell &quot;/usr/bin/zsh&quot;)
zsh-shell

ELISP&gt; zsh-shell
&quot;/usr/bin/zsh&quot;
ELISP&gt;

;;; Define a variable
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;;; Set is not used very much
;;
ELISP&gt; (set 'avar &quot;hello world&quot;)
&quot;hello world&quot;

ELISP&gt; avar
&quot;hello world&quot;
ELISP&gt;

;;;;; The most used command for assignment is setq
;;
ELISP&gt; (setq x 10)
10

ELISP&gt; (setq avar &quot;hello world&quot;)
&quot;hello world&quot;

ELISP&gt; x
10

ELISP&gt; avar
&quot;hello world&quot;
ELISP&gt;

ELISP&gt; (setq my-list '(10 20 30 40))
(10 20 30 40)

ELISP&gt; my-list
(10 20 30 40)

;;; Multiple Assignment
;;
ELISP&gt; (setq a 10 b 20 c &quot;Emacs&quot;)
&quot;Emacs&quot;
ELISP&gt; a
10
ELISP&gt; b
20
ELISP&gt; c
&quot;Emacs&quot;
ELISP&gt;

;; Dynamic Scoping  (Local Variables)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
ELISP&gt; (let ((x 1) (y 10)) (+ (* 4 x) (* 5 y)) )
54
ELISP&gt; x
    ** Eval error **  Symbol's value as variable is void: x
ELISP&gt; y
    ** Eval error **  Symbol's value as variable is void: y
ELISP&gt;
</code></pre>
<h2 id="å‡½æ•°å®šä¹‰">å‡½æ•°å®šä¹‰</h2>
<h3 id="å®šä¹‰ç®€å•å‡½æ•°">å®šä¹‰ç®€å•å‡½æ•°</h3>
<p>è¯­æ³•: (defun <function name> (<parameters>) (<body>))</p>
<pre><code>ELISP&gt; (defun afunction (a b c) (+ a b c))
afunction

ELISP&gt; (afunction 10 20 30)
60

ELISP&gt; (defun myfun () (message &quot;Hello Emacs&quot;))
myfun
ELISP&gt; (myfun)
&quot;Hello Emacs&quot;
ELISP&gt;


ELISP&gt;
ELISP&gt; (defun signum (n)
     (cond ((&gt; n 0) 1 )
       ((&lt; n 0) -1)
       (0)))
signum
ELISP&gt; (signum 10)
1
ELISP&gt; (signum 0)
0
ELISP&gt; (signum -23)
-1
ELISP&gt;


ELISP&gt; (defun factorial (n)
     (if (= n 0)
     1
     (* n (factorial (- n 1)))))
factorial

ELISP&gt; (factorial 5)
120
ELISP
</code></pre>
<h3 id="åŒ¿åå‡½æ•°lambdaå‡½æ•°">åŒ¿åå‡½æ•°/Lambdaå‡½æ•°</h3>
<p>è¯­æ³•: (lambda (<parameters>) (<body>))</p>
<pre><code>ELISP&gt; (lambda (x) (+ x 3))
(lambda
  (x)
  (+ x 3))

;;; Applying Lambda Functions
;;

ELISP&gt; ((lambda (x) (+ x 3)) 4)
7
ELISP&gt; (funcall (lambda (x) (+ x 3)) 4)
7
ELISP&gt;

;;; Storing Lambda Function in Variable
;;
;;

ELISP&gt; (defvar add3 (lambda (x) (+ x 3)))
add3


ELISP&gt; add3
(lambda
  (x)
  (+ x 3))

ELISP&gt; (funcall add3 10)
13

ELISP&gt; (add3 10)
    ** Eval error **  Symbol's function definition is void: add3

ELISP&gt; (funcall #'add3 10)
    ** Eval error **  Symbol's function definition is void: add3
ELISP&gt;

;;; Passing Lambda Function to functions
;;
ELISP&gt; (mapcar (lambda (x) (+ x 3))  '(1 2 3 4 5))
(4 5 6 7 8)
</code></pre>
<h3 id="å‡½æ•°ä½œä¸ºå‚æ•°">å‡½æ•°ä½œä¸ºå‚æ•°</h3>
<p>è¯­æ³•: (caller-function #'<function-1> #'<function-1> arg1 arg2 â€¦)</p>
<p>åœ¨å‡½æ•°å†…éƒ¨ï¼Œä½¿ç”¨ <code>funcall</code> è°ƒç”¨å‡½æ•°ä½œä¸ºå‚æ•°</p>
<pre><code>ELISP&gt; (mapcar log '(1 10 100 1000))
    ** Eval error **  Symbol's value as variable is void: log


ELISP&gt; (mapcar #'log10 '(1 10 100 1000))
(0.0 1.0 2.0 3.0)

(defun sum-fun (f1 f2 x)
  (+ (funcall f1 x) (funcall f2 x)))

ELISP&gt; (sum-fun #'log #'exp 3)
21.18414921185578
ELISP&gt;

ELISP&gt; (+ (log 3) (exp 3))
21.18414921185578
ELISP&gt;

ELISP&gt; (sum-fun (lambda (x) (* 3 x))
	(lambda (x) (* 4 x))
	5)
35
ELISP&gt;

ELISP&gt; (defun 1+ (x) (+ 1 x))
1+
ELISP&gt; (defun 3* (x) (* 3 x))
3*

ELISP&gt; (sum-fun #'1+  #'3* 4)
17
ELISP&gt;

ELISP&gt; (sum-fun #'1+  (lambda (x) (* 3 x)) 4)
17
ELISP&gt;
</code></pre>
<h3 id="å¤šå‚å‡½æ•°">å¤šå‚å‡½æ•°</h3>
<pre><code>(defun sum (&amp;rest numbers)
  (apply #'+ numbers))

ELISP&gt; (sum 1 2 3 4 5 6)
21


ELISP&gt; (apply #'sum '(1 2 3 5 6))
17

ELISP&gt; (apply #'sum (list 1 2 3 5 (+ 6 5 2)))
24

ELISP&gt; (apply #'sum '())
0

ELISP&gt; (apply #'sum nil)
0

ELISP&gt; (sum nil)
    ** Eval error **  Wrong type argument: number-or-marker-p, ni

;;----------------------------------

(defun sum-prod (a &amp;rest xs)
  (* a (apply #'+ xs)))


ELISP&gt; (sum-prod 3 1 2 3 4 5)
45

ELISP&gt; (sum-prod 1 1 2 3 4 5)
15
</code></pre>
<h3 id="å¯é€‰å‚æ•°å‡½æ•°">å¯é€‰å‚æ•°å‡½æ•°</h3>
<pre><code>(defun test-optional (a &amp;optional b)
  (list a b))

ELISP&gt; (test-optional 10 20)
(10 20)

ELISP&gt; (test-optional 10 )
(10 nil)

;--------------------------------;

(defun test-optional2 (a b &amp;optional b c d e)
  (list :a a :b b :c c :d d :e e))

ELISP&gt; (test-optional2 0 1 2 3 4 5 )
(:a 0 :b 2 :c 3 :d 4 :e 5)


ELISP&gt; (test-optional2 0 1 2 3 4  )
(:a 0 :b 2 :c 3 :d 4 :e nil)

ELISP&gt; (test-optional2 0 1 2 3   )
(:a 0 :b 2 :c 3 :d nil :e nil)

ELISP&gt; (test-optional2 0 1 2    )
(:a 0 :b 2 :c nil :d nil :e nil)

ELISP&gt; (test-optional2 0 1  )
(:a 0 :b nil :c nil :d nil :e nil)

ELISP&gt; (test-optional2 0 1)
(:a 0 :b nil :c nil :d nil :e nil)

;--------------------------------;

(defun test-optional-default-b (a &amp;optional b)
  (if b
      (list a b)
      (list a &quot;b is null&quot;)))

ELISP&gt; (test-optional-default-b 1 2)
(1 2)

ELISP&gt; (test-optional-default-b 1)
(1 &quot;b is null&quot;)

ELISP&gt; (test-optional-default-b 1 nil)
(1 &quot;b is null&quot;)
</code></pre>
<h3 id="å«å±æ€§åˆ—è¡¨å‚æ•°å‡½æ•°">å«å±æ€§åˆ—è¡¨å‚æ•°å‡½æ•°</h3>
<pre><code>(defun make-shell-interface (&amp;rest params)
  &quot;
  Create a shell interface.

  Possible parameters:

    :name      Name of shell
    :type      ['sh, 'bash, ...]
    :path      Path to program
    :buffer    Name of buffer

  &quot;
  (let
       ((name   (plist-get params :name ))
	(type   (plist-get params :type))
	(path   (plist-get params :path))
	(buffer (plist-get params :buffer)))
    (list
     (cons 'name buffer)
     (cons 'type type)
     (cons 'path path)
     (cons 'buffer buffer))))


ELISP&gt; (make-shell-interface :name &quot;pylaucher&quot; :path &quot;/usr/bin/python&quot; :type 'sh :buffer &quot;pyshell&quot;)
((name . &quot;pyshell&quot;)
 (type . sh)
 (path . &quot;/usr/bin/python&quot;)
 (buffer . &quot;pyshell&quot;))

ELISP&gt; (make-shell-interface :name &quot;pylaucher&quot; :path &quot;/usr/bin/python&quot; :type 'sh)
((name)
 (type . sh)
 (path . &quot;/usr/bin/python&quot;)
 (buffer))

ELISP&gt; (make-shell-interface :name &quot;pylaucher&quot; :path &quot;/usr/bin/python&quot; :type 'bash)
((name)
 (type . bash)
 (path . &quot;/usr/bin/python&quot;)
 (buffer))

ELISP&gt; (make-shell-interface :name &quot;pylaucher&quot; :path &quot;/usr/bin/python&quot;)
((name)
 (type)
 (path . &quot;/usr/bin/python&quot;)
 (buffer))

ELISP&gt; (make-shell-interface :name &quot;pylaucher&quot; )
((name)
 (type)
 (path)
 (buffer))

ELISP&gt; (make-shell-interface  )
((name)
 (type)
 (path)
 (buffer))

ELISP&gt; (make-shell-interface :buffer &quot;pyshell&quot;  :path &quot;/usr/bin/python&quot; :type 'sh :name &quot;pylaucher&quot;)
((name . &quot;pyshell&quot;)
 (type . sh)
 (path . &quot;/usr/bin/python&quot;)
 (buffer . &quot;pyshell&quot;))
</code></pre>
<h3 id="closures">Closures</h3>
<p>elispæ–¹è¨€é»˜è®¤ä¸æ”¯æŒclosureï¼Œæ‰€ä»¥ä¸‹é¢çš„ä»£ç ä¸ä¼šåƒSchemeæˆ–Common Lispä¸€æ ·æ‰§è¡Œã€‚</p>
<p>å‚è€ƒï¼š</p>
<ul>
<li>
<p><a href="https://www.emacswiki.org/emacs/LexicalBinding">EmacsWiki: Lexical Binding</a></p>
</li>
<li>
<p><a href="https://www.emacswiki.org/emacs/DynamicBindingVsLexicalBinding">EmacsWiki: Dynamic Binding Vs Lexical Binding</a></p>
</li>
<li>
<p><a href="https://nullprogram.com/blog/2013/12/30/">Emacs Lisp Readable Closures Â« null program</a></p>
</li>
<li>
<p><a href="https://www.jamesporter.me/2013/06/14/emacs-lisp-closures-exposed.html">https://www.jamesporter.me/2013/06/14/emacs-lisp-closures-exposed.html</a></p>
</li>
<li>
<p><a href="http://technical-dresese.blogspot.com/2011/04/brief-demonstration-of-emacs-new.html">Technical Dresese: A brief demonstration of emacs new lexical bindings</a></p>
<pre><code>(defun make-adder (x)
      (lambda (y) (+ x y)))


    ELISP&gt;
    ELISP&gt; (make-adder 3)
    (lambda
      (y)
      (+ x y))

    ELISP&gt; ((make-adder 3) 4)
        ** Eval error **  Invalid function: (make-adder 3)
    ELISP&gt; (funcall (make-adder 3) 4)
        ** Eval error **  Symbol's value as variable is void: x
    ELISP&gt; (map (make-adder 3) '(1 2 3 4 5))
        ** Eval error **  Symbol's value as variable is void: x
    ELISP&gt;
</code></pre>
</li>
</ul>
<p>æ”¯æŒclosureçš„ä»£ç ï¼š</p>
<pre><code>(setq lexical-binding t)

(defun make-adder (x)
  (lambda (y) (+ x y)))

ELISP&gt; (make-adder 3)
(closure
 ((x . 3)
  t)
 (y)
 (+ x y))

ELISP&gt; ((make-adder 3) 4)
    ** Eval error **  Invalid function: (make-adder 3)
ELISP&gt;

ELISP&gt; (funcall (make-adder 3) 4)
7
ELISP&gt;

ELISP&gt; (mapcar (make-adder 3) '(1 2 3 4 5))
(4 5 6 7 8)


;;;; Sometimes is better to create macro rather than a higher order function


(defmacro make-sum-fun (f1 f2)
  `(lambda (x) (+ (,f1 x) (,f2 x))))

ELISP&gt;
ELISP&gt; (funcall (make-sum-fun sin cos) 3)
-0.8488724885405782
ELISP&gt;
ELISP&gt; (make-sum-fun sin cos)
(closure
 (t)
 (x)
 (+
  (sin x)
  (cos x)))

ELISP&gt; (map (make-sum-fun sin cos) '(1 2 3 4 5))
(1.3817732906760363 0.4931505902785393 -0.8488724885405782 -1.4104461161715403 -0.6752620891999122)
</code></pre>
<p>åœ¨ <code>~/.emacs.d/init.el</code> ä¸­æ·»åŠ å¦‚ä¸‹é…ç½®ä»¥æ”¯æŒclosure.</p>
<pre><code>(setq lexical-binding t)
</code></pre>
<h2 id="åˆ—è¡¨æ“ä½œ">åˆ—è¡¨æ“ä½œ</h2>
<p>å‚è€ƒï¼š</p>
<ul>
<li>
<p><a href="https://www.fincher.org/tips/Languages/Emacs.shtml">https://www.fincher.org/tips/Languages/Emacs.shtml</a></p>
<pre><code>;; Defining a List
    ;;
    ;; An emacs list can contain elements of almost any type.
    ;;
    ELISP&gt; '( &quot;a&quot; 2323 &quot;b&quot; 21.2323 &quot;hello&quot; &quot;emacs&quot; nil () (34 134) '(+ 2 3 5))
    (&quot;a&quot; 2323 &quot;b&quot; 21.2323 &quot;hello&quot; &quot;emacs&quot; nil nil
     (34 134)
     '(+ 2 3 5))

    ELISP&gt; (quote (1 3 3 4 5))
    (1 3 3 4 5)

    ;;;;; Empty List
    ;;
    ELISP&gt; nil
    nil
    ELISP&gt; '()
    nil
    ELISP&gt;

    ;; Length of a list
    ELISP&gt; (length '(1 2 3 4 5 6))
    6
    ELISP&gt;


    ;; nth element of a list
    ;;
    ELISP&gt; (nth 0 '(0 1 2 3 4 5))
    0
    ELISP&gt; (nth 2 '(0 1 2 3 4 5))
    2
    ELISP&gt; (nth 5 '(0 1 2 3 4 5))
    5
    ELISP&gt; (nth 10 '(0 1 2 3 4 5))
    nil
    ELISP&gt;


    ;; Membership test
    ;; member returns null if the element is not member of the list
    ;;
    ELISP&gt; (member 2 '(0 1 2 3 4 5))
    (2 3 4 5)

    ELISP&gt; (member 10 '(0 1 2 3 4 5))
    nil
    ELISP&gt;

    ;; Position of list element (prior to emacs 24.4)
    ;;
    ELISP&gt; (position 7 '(5 6 7 8))
    2

    ELISP&gt; (position 17 '(5 6 7 8))
    nil
    ELISP&gt;

    ;; Position of list element (emacs 24.4 or later)
    ;;
    ELISP&gt; (cl-position 7 '(5 6 7 8))
    2

    ELISP&gt; (cl-position 17 '(5 6 7 8))
    nil
    ELISP&gt;

    ;; cdr
    ;;
    ;; Removes first element of the list, returns the list tail.
    ;;
    ELISP&gt; (cdr '(1 2 3 4 5))
    (2 3 4 5)

    ;; car
    ;;
    ;; Returns the first list element
    ;;
    ELISP&gt; (car '(1 2 3 4 5))
    1
    ELISP&gt;


    ;; cons
    ;;
    ;; List constructor
    ;;
    ELISP&gt; (cons 10 '(1 2 3 4))
    (10 1 2 3 4)

    ELISP&gt; (cons 1 (cons 2 (cons 3 (cons 4 (cons 5 '())))))
    (1 2 3 4 5)

    ;; Last element of a list
    ;;
    ;;
    ELISP&gt; (car (last '(1 2 3 4 5)))
    5
    ELISP&gt;


    ;; Reverse a list
    ;;
    ELISP&gt; (reverse '(1 2 3 4 5))
    (5 4 3 2 1)


    ;; Append lists
    ;;
    ;; Note: nil also means an empty list
    ;;
    ELISP&gt; (append '(1 2) '( &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot;))
    (1 2 &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot;)

    ELISP&gt; (append '(1 2) nil '( &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot;) nil)
    (1 2 &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot;)



    ;; Filter list elements given a predicate function
    ;;
    ;;
    ELISP&gt; (remove-if-not (lambda (x) (&gt; x 2)) '(1 2 3 4 5 6 7 8 9 10))
    (3 4 5 6 7 8 9 10)

    ;; Test if list is empty
    ;;
    ELISP&gt; (null '(1 2 3 4 5))
    nil
    ELISP&gt; (null '())
    t
    ELISP&gt; (null nil)
    t
    ELISP&gt;

    ;; Drop the firsts n elements of a list
    ;;
    ;;
    ELISP&gt; (nthcdr 2 '(1 2 3 4))
    (3 4)

    ELISP&gt; (nthcdr 3 '(1 2 3 4))
    (4)

    ELISP&gt; (nthcdr 13 '(1 2 3 4))
    nil
    ELISP&gt;

    ;; Delete an element of a list
    ;;
    ;;
    ELISP&gt; (delq 1 '(1 2 3 4))
    (2 3 4)


    ELISP&gt; (delq 10 '(1 2 3 4))
    (1 2 3 4)

    ;; It doesn't work to delete sublists
    ;;
    ELISP&gt; (delq (5) '(1 2 (5) 3 4))
        ** Eval error **  Invalid function: 5
    ELISP&gt; (delq '(5) '(1 2 (5) 3 4))
    (1 2
       (5)
       3 4)

    ELISP&gt; (delete '(5) '(1 2 (5) 3 4))
    (1 2 3 4)

    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

    ;; Convert Vector to List
    ;;
    ;;
    ELISP&gt; (coerce [1 2 3] 'list)
    (1 2 3)

    ;; Convert List to Vector
    ;;
    ELISP&gt; (coerce '(1 2 3) 'vector)
    [1 2 3]

    ELISP&gt; (number-sequence 0 10 2)
    (0 2 4 6 8 10)

    ELISP&gt; (number-sequence 9 4 -1)
    (9 8 7 6 5 4)


    ;; Modify list variables.
    ;;
    ELISP&gt; alist
    (a b c d e)

    ELISP&gt; (push 'f alist)
    (f a b c d e)

    ELISP&gt; alist
    (f a b c d e)

    ELISP&gt; (pop alist)
    f

    ELISP&gt; alist
    (a b c d e)

    ELISP&gt; (pop alist)
    a
    ELISP&gt; alist
    (b c d e)

    ELISP&gt;
</code></pre>
</li>
</ul>
<h2 id="å…³è”åˆ—è¡¨å’Œå±æ€§åˆ—è¡¨">å…³è”åˆ—è¡¨å’Œå±æ€§åˆ—è¡¨</h2>
<h3 id="æ¦‚è§ˆ-1">æ¦‚è§ˆ</h3>
<p>å…³è”åˆ—è¡¨æ˜¯ä¸€ç³»åˆ—conså¯¹ï¼Œè¿™é‡Œæˆ‘å¯ä»¥ç§°ä½œ <code>clist</code> æˆ–è€… ç”±ä¸¤ä¸ªå…ƒç´ ç»„æˆçš„åˆ—è¡¨çš„é›†åˆï¼Œå¯ä»¥ç§°ä¸º <code>alist</code></p>
<p><strong>å…³è”åˆ—è¡¨ç±»å‹ï¼šclist</strong></p>
<p>é”®: a, x, 2 and 4 å€¼: b, y, 3 and (1 2 3 4 5)</p>
<pre><code>ELISP&gt; '((a . b) (x . y) (2 . 3) (4 . (1 2 3 4 5)))
((a . b)
 (x . y)
 (2 . 3)
 (4 1 2 3 4 5)

ELISP&gt; (cons 'a 'b)
(a . b)

ELISP&gt; (cons 'a (cons 'b (cons 'c nil)))
(a b c)
</code></pre>
<p><strong>å…³è”åˆ—è¡¨ç±»å‹ï¼šalist</strong></p>
<pre><code>ELISP&gt; '((a  b) (x  y) (2  3) (4  (1 2 3 4 5)))
((a b)
 (x y)
 (2 3)
 (4
  (1 2 3 4 5)))

ELISP&gt; (list (list 'a 'b) (list 'x 'y) (list 2 3) (list 2 '(1 2 3 4 5)))
((a b)
 (x y)
 (2 3)
 (2
  (1 2 3 4 5)))
</code></pre>
<p><code>alist</code> ä¸åƒ <code>clist</code> æœ‰æ­§ä¹‰ã€‚</p>
<p><strong>å±æ€§åˆ—è¡¨ï¼šPlist</strong></p>
<p>å±æ€§åˆ—è¡¨æ˜¯è¿ç»­çš„é”®å€¼å¯¹é›†åˆï¼Œå®ƒçš„ä¼˜åŠ¿æ˜¯æ‹¬å·å°‘å’Œå¯è¯»æ€§é«˜ã€‚</p>
<pre><code>'(:key1 value1 :key2 value2 :key3 1002.23 :key4 (a b c d e))

ELISP&gt; '(:key1 value1 :key2 value2 :key3 1002.23 :key4 (a b c d e))
(:key1 value1 :key2 value2 :key3 1002.23 :key4
       (a b c d e))

;;; It is more useful in configuration files

(
:key1  value1
:key2  value2
:key3  value3
:key4  (a b c d e )
)
</code></pre>
<h3 id="å…³è”åˆ—è¡¨alist">å…³è”åˆ—è¡¨/Alist</h3>
<pre><code>ELISP&gt; (setq dict
'((pine . cones)
 (oak . acorns)
 (maple . seeds)))
((pine . cones)
 (oak . acorns)
 (maple . seeds))

ELISP&gt; dict
((pine . cones)
 (oak . acorns)
 (maple . seeds))

;; Get a cell associated with a key
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
ELISP&gt;
ELISP&gt; (assoc 'oak dict)
(oak . acorns)

ELISP&gt; (assoc 'wrong dict)
nil

;; Get a Key
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

ELISP&gt; (car (assoc 'oak dict))
oak
ELISP&gt; (cdr (assoc 'oak dict))
acorns
ELISP&gt;


ELISP&gt; (car (assoc 'oak dict))
oak
ELISP&gt;

;; Get all keys
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

ELISP&gt; (mapcar #'car dict)
(pine oak maple)

;; Get all values
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

ELISP&gt; (mapcar #'cdr dict)
(cones acorns seeds)
</code></pre>
<p>ä¾‹ï¼šè¿‡æ»¤å¤šä¸ªé”®</p>
<pre><code>ELISP&gt; (defvar language-list
  '(
   (&quot;io&quot; . ((:command . &quot;io&quot;)
         (:description . &quot;Run IO Language script&quot;)))
    (&quot;lua&quot; . ((:command . &quot;lua&quot;)
          (:description . &quot;Run Lua script&quot;)))
    (&quot;groovy&quot; . ((:command . &quot;groovy&quot;)
         (:description . &quot;Run Groovy&quot;)))
    (&quot;scala&quot; . ((:command . &quot;scala&quot;)
        (:cmdopt . &quot;-Dfile.encoding=UTF-8&quot;)
        (:description . &quot;Run Scala file with scala command&quot;)))

    (&quot;haml&quot; . ((:command . &quot;haml&quot;)
           (:exec    . &quot;%c %o %s&quot;)
           (:description . &quot;Convert HAML to HTML&quot;)))
    (&quot;sass&quot; . ((:command . &quot;sass&quot;)
           (:exec    . &quot;%c %o --no-cac&quot;)))
 ))
language-list


ELISP&gt; (assoc  &quot;scala&quot;  language-list )
(&quot;scala&quot;
 (:command . &quot;scala&quot;)
 (:cmdopt . &quot;-Dfile.encoding=UTF-8&quot;)
 (:description . &quot;Run Scala file with scala command&quot;))

ELISP&gt; (assoc  &quot;lua&quot;  language-list )
(&quot;lua&quot;
 (:command . &quot;lua&quot;)
 (:description . &quot;Run Lua script&quot;))

ELISP&gt; (assoc  &quot;wrong&quot;  language-list )
nil

ELISP&gt; (assoc ':command (assoc  &quot;scala&quot;  language-list ))
(:command . &quot;scala&quot;)

ELISP&gt; (cdr (assoc ':command (assoc  &quot;scala&quot;  language-list )))
&quot;scala&quot;
ELISP&gt;

ELISP&gt; (assoc ':description (assoc  &quot;scala&quot;  language-list ))
(:description . &quot;Run Scala file with scala command&quot;)

ELISP&gt; (cdr (assoc ':description (assoc  &quot;scala&quot;  language-list )))
&quot;Run Scala file with scala command&quot;
ELISP&gt;

ELISP&gt; (mapcar 'car language-list)
(&quot;io&quot; &quot;lua&quot; &quot;groovy&quot; &quot;scala&quot; &quot;haml&quot; &quot;sass&quot;)

ELISP&gt; (mapcar 'cdr language-list)
(((:command . &quot;io&quot;)
  (:description . &quot;Run IO Language script&quot;))
 ((:command . &quot;lua&quot;)
  (:description . &quot;Run Lua script&quot;))
 ((:command . &quot;groovy&quot;)
  (:description . &quot;Run Groovy&quot;))
 ((:command . &quot;scala&quot;)
  (:cmdopt . &quot;-Dfile.encoding=UTF-8&quot;)
  (:description . &quot;Run Scala file with scala command&quot;))
 ((:command . &quot;haml&quot;)
  (:exec . &quot;%c %o %s&quot;)
  (:description . &quot;Convert HAML to HTML&quot;))
 ((:command . &quot;sass&quot;)
  (:exec . &quot;%c %o --no-cac&quot;)))

ELISP&gt;

ELISP&gt; (mapcar (lambda (x) (
                 list
                 (car x)
                 (cdr x)
                 ))
                language-list)
((&quot;io&quot;
  ((:command . &quot;io&quot;)
   (:description . &quot;Run IO Language script&quot;)))
 (&quot;lua&quot;
  ((:command . &quot;lua&quot;)
   (:description . &quot;Run Lua script&quot;)))
 (&quot;groovy&quot;
  ((:command . &quot;groovy&quot;)
   (:description . &quot;Run Groovy&quot;)))
 (&quot;scala&quot;
  ((:command . &quot;scala&quot;)
   (:cmdopt . &quot;-Dfile.encoding=UTF-8&quot;)
   (:description . &quot;Run Scala file with scala command&quot;)))
 (&quot;haml&quot;
  ((:command . &quot;haml&quot;)
   (:exec . &quot;%c %o %s&quot;)
   (:description . &quot;Convert HAML to HTML&quot;)))
 (&quot;sass&quot;
  ((:command . &quot;sass&quot;)
   (:exec . &quot;%c %o --no-cac&quot;))))

ELISP&gt;

ELISP&gt; (mapcar (lambda (x) (
     list
     (car x)
     (assoc ':command       (cdr x))
     (assoc ':cmdopt        (cdr x))
     (assoc ':description   (cdr x))
     ))
    language-list)

((&quot;io&quot;
  (:command . &quot;io&quot;)
  nil
  (:description . &quot;Run IO Language script&quot;))
 (&quot;lua&quot;
  (:command . &quot;lua&quot;)
  nil
  (:description . &quot;Run Lua script&quot;))
 (&quot;groovy&quot;
  (:command . &quot;groovy&quot;)
  nil
  (:description . &quot;Run Groovy&quot;))
 (&quot;scala&quot;
  (:command . &quot;scala&quot;)
  (:cmdopt . &quot;-Dfile.encoding=UTF-8&quot;)
  (:description . &quot;Run Scala file with scala command&quot;))
 (&quot;haml&quot;
  (:command . &quot;haml&quot;)
  nil
  (:description . &quot;Convert HAML to HTML&quot;))
 (&quot;sass&quot;
  (:command . &quot;sass&quot;)
  nil nil))

ELISP&gt;


ELISP&gt; (mapcar (lambda (x) (
     list
     (car x)
     (cdr (assoc ':command   (cdr x)))
     (cdr (assoc ':cmdopt       (cdr x)))
     (cdr (assoc ':description   (cdr x)))
     ))

	language-list)
((&quot;io&quot; &quot;io&quot; nil &quot;Run IO Language script&quot;)
 (&quot;lua&quot; &quot;lua&quot; nil &quot;Run Lua script&quot;)
 (&quot;groovy&quot; &quot;groovy&quot; nil &quot;Run Groovy&quot;)
 (&quot;scala&quot; &quot;scala&quot; &quot;-Dfile.encoding=UTF-8&quot; &quot;Run Scala file with scala command&quot;)
 (&quot;haml&quot; &quot;haml&quot; nil &quot;Convert HAML to HTML&quot;)
 (&quot;sass&quot; &quot;sass&quot; nil nil))

ELISP&gt;

ELISP&gt; (defun get-value (alist key) (cdr (assoc key alist)))
get-value
ELISP&gt; (get-value language-list &quot;scala&quot;)
((:command . &quot;scala&quot;)
 (:cmdopt . &quot;-Dfile.encoding=UTF-8&quot;)
 (:description . &quot;Run Scala file with scala command&quot;))

ELISP&gt; (get-value language-list &quot;lua&quot;)
((:command . &quot;lua&quot;)
 (:description . &quot;Run Lua script&quot;))

ELISP&gt;
ELISP&gt; (get-value language-list &quot;0&quot;)
nil
ELISP&gt;


ELISP&gt; (defun get-key-value (alist key field)
        (cdr (assoc  field  (cdr (assoc key alist))  )))
get-key-value
ELISP&gt;
ELISP&gt; (get-key-value language-list &quot;scala&quot; ':description)
&quot;Run Scala file with scala command&quot;
ELISP&gt;

ELISP&gt; (get-key-value language-list &quot;scala&quot; ':command)
&quot;scala&quot;
ELISP&gt;
</code></pre>
<h3 id="å±æ€§åˆ—è¡¨">å±æ€§åˆ—è¡¨</h3>
<pre><code>ELISP&gt; (defvar plst (list :buffer (current-buffer) :line 10 :pos 2000))
plst

ELISP&gt;
ELISP&gt; (plist-get plst :line)
10

ELISP&gt; (plist-get plst :pos)
2000

ELISP&gt; (plist-get plst :buffer)
#&lt;buffer *ielm*&gt;
ELISP&gt;

ELISP&gt;
ELISP&gt; (plist-get plst :buffdfds)
nil
ELISP&gt;

ELISP&gt; (plist-member plst :buffer)
(:buffer #&lt;buffer *ielm*&gt; :line 10 :pos 2000)

ELISP&gt; (plist-member plst :bufferasd)
nil
ELISP&gt;

ELISP&gt; (plist-put plst :winconf (current-window-configuration))
(:buffer #&lt;buffer *ielm*&gt; :line 10 :pos 2000 :winconf #&lt;window-configuration&gt;)

ELISP&gt; plst
(:buffer #&lt;buffer *ielm*&gt; :line 10 :pos 2000 :winconf #&lt;window-configuration&gt;)

ELISP&gt;
</code></pre>
<h3 id="è½¬æ¢alistæˆplistå’Œvice-versa">è½¬æ¢AlistæˆPlistå’Œvice-versa</h3>
<pre><code>;; Alist to plist
(defun plist-&gt;alist (plist)
  (if (null plist)
      '()
      (cons
       (list (car plist) (cadr plist))
       (plist-&gt;alist (cddr plist)))))

ELISP&gt; (plist-&gt;alist (list :x 10 :y 20 :name &quot;point&quot;))
((:x 10)
 (:y 20)
 (:name &quot;point&quot;))

;;; Converts association list to plist
(defun alist-&gt;plist (assocl)
  (if (null assocl)
      '()
    (let
    ((hd (car assocl))
     (tl (cdr assocl)))
      (cons (car hd)
	(cons (cadr hd)
      (alist-&gt;plist tl))))))

;;; Converts plist to clist (List of cons pairs)
(defun plist-&gt;clist (plist)
  (if (null plist)
      '()
      (cons
       (cons (car plist) (cadr plist))
      (plist-&gt;clist (cddr plist)))))

ELISP&gt; (plist-&gt;clist (list :x 10 :y 20 :name &quot;point&quot;))
((:x . 10)
 (:y . 20)
 (:name . &quot;point&quot;))

;; Separates a property list into two lists of keys and values.
;;
(defun plist-&gt;kv (plist)
  (let ((alist (plist-&gt;alist plist)))
    (cons
     (mapcar #'car alist)
     (mapcar #'cdr alist))))

ELISP&gt; (setq al (plist-&gt;alist (list :x 10 :y 20 :name &quot;point&quot;)))
((:x 10)
 (:y 20)
 (:name &quot;point&quot;))

ELISP&gt; (alist-&gt;plist al)
(:x 10 :y 20 :name &quot;point&quot;)

ELISP&gt;

(setq keylist
    '(&quot;M-i&quot;  'previous-line
      &quot;M-j&quot;  'backward-char
      &quot;M-k&quot;  'next-line
      &quot;M-l&quot;  'forward-char))


ELISP&gt; (setq kv (plist-&gt;kv keylist))
((&quot;M-i&quot; &quot;M-j&quot; &quot;M-k&quot; &quot;M-l&quot;)
 ('previous-line)
 ('backward-char)
 ('next-line)
 ('forward-char))

ELISP&gt; (car kv)
(&quot;M-i&quot; &quot;M-j&quot; &quot;M-k&quot; &quot;M-l&quot;)

ELISP&gt; (cdr kv)
(('previous-line)
 ('backward-char)
 ('next-line)
 ('forward-char))

ELISP&gt;
</code></pre>
<h2 id="å­—ç¬¦ä¸²">å­—ç¬¦ä¸²</h2>
<pre><code>;; Split String

ELISP&gt; (split-string &quot;  two words &quot;)
(&quot;two&quot; &quot;words&quot;)

ELISP&gt;

ELISP&gt; (split-string &quot;o\no\no&quot; &quot;\n&quot; t)
(&quot;o&quot; &quot;o&quot; &quot;o&quot;)

ELISP&gt; (split-string &quot;Soup is good food&quot; &quot;o*&quot; t)
(&quot;S&quot; &quot;u&quot; &quot;p&quot; &quot; &quot; &quot;i&quot; &quot;s&quot; &quot; &quot; &quot;g&quot; &quot;d&quot; &quot; &quot; &quot;f&quot; &quot;d&quot;)

ELISP&gt;

;; Format String

ELISP&gt; (format-time-string &quot;%Y/%m/%d %H:%M:%S&quot; (current-time))
&quot;2015/06/26 06:10:04&quot;
ELISP&gt;
ELISP&gt;


;; Concatenate Strings

ELISP&gt; (concat &quot;The &quot; &quot;quick brown &quot; &quot;fox.&quot;)
&quot;The quick brown fox.&quot;
ELISP&gt;

ELISP&gt; (mapconcat 'identity '(&quot;aaa&quot; &quot;bbb&quot; &quot;ccc&quot;) &quot;,&quot;)
&quot;aaa,bbb,ccc&quot;
ELISP&gt; (split-string &quot;aaa,bbb,ccc&quot; &quot;,&quot;)
ELISP&gt; (split-string &quot;aaa,bbb,ccc&quot; &quot;,&quot;)
(&quot;aaa&quot; &quot;bbb&quot; &quot;ccc&quot;)

;; String Width

ELISP&gt; (string-width &quot;hello world&quot;)
11
ELISP&gt;
ELISP&gt; (substring &quot;Freedom Land&quot; 0 5)
&quot;Freed&quot;
ELISP&gt;
ELISP&gt; (string-match &quot;ce&quot; &quot;central park&quot;)
0
ELISP&gt; (string-match &quot;gt&quot; &quot;central park&quot;)
nil
ELISP&gt;


;;;;; Misc

ELISP&gt; (make-string 5 ?x)
&quot;xxxxx&quot;
ELISP&gt; (make-string 5 ?a)
&quot;aaaaa&quot;
ELISP&gt; (make-string 5 ?r)
&quot;rrrrr&quot;
ELISP&gt; (make-string 15 ?r)
&quot;rrrrrrrrrrrrrrr&quot;
ELISP&gt;
</code></pre>
<p><strong>elispç¬¦å·/å­—ç¬¦ä¸²è½¬æ¢</strong></p>
<pre><code>; Convert a symbol to string
ELISP&gt; (symbol-name 'wombat)
&quot;wombat&quot;

; Convert a String to Symbol
ELISP&gt; (intern &quot;wombat&quot;)
wombat
</code></pre>
<p><strong>è¯»å–å­—ç¬¦ä¸²ä¸­çš„Sè¡¨è¾¾å¼</strong></p>
<pre><code>ELISP&gt; (read-from-string
        &quot;(
           (POINT1  (X  10.2323)  (Y   20.2323))
           (POINT2  (x  0.2)          (Y 923.23))
           (POINT3  (x -10.5)       (Y 78,23))
         )&quot;)
(((POINT1
   (X 10.2323)
   (Y 20.2323))
  (POINT2
   (x 0.2)
   (Y 923.23))
  (POINT3
   (x -10.5)
   (Y 78
      (\, 23))))
 . 174)

ELISP&gt;
</code></pre>
<h2 id="ç¬¦å·">ç¬¦å·</h2>
<pre><code>;;; Convert a string to symbol

ELISP&gt; (intern &quot;a-symbol&quot;)
a-synmbol
ELISP&gt; (symbolp (intern &quot;a-symbol&quot;))
t
ELISP&gt;

;;; Convert a symbol to a string

ELISP&gt; (symbol-name 'symbol)
&quot;symbol&quot;
ELISP&gt;

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

ELISP&gt; (setq sym '(1 2 3 4 5))
(1 2 3 4 5)

ELISP&gt; sym
(1 2 3 4 5)

;;; Test if variable is defined
ELISP&gt; (boundp 'sym)
t
ELISP&gt;

;;; Test if variable sym is a symbol
ELISP&gt; (symbolp sym)
nil

;;; Test if the symbol sym is a symbol
ELISP&gt; (symbolp 'sym)
t
ELISP&gt;

;; Get symbol as string
;;
ELISP&gt; (symbol-name 'sym)
&quot;sym&quot;

;; Get value from a symbol
;;
ELISP&gt; (symbol-value 'sym)
(1 2 3 4 5)

ELISP&gt; (symbol-function 'sym)
nil

ELISP&gt; (symbol-plist 'sym)
nil

;;-------------------------;;

ELISP&gt; (defun func (x y) (+ (* 3 x) (* 4 y)))
func

ELISP&gt; (func 10 2)
38
ELISP&gt;

;;; Check if function is defined
;;
ELISP&gt; (fboundp 'func)
t
ELISP&gt; (fboundp 'sym)
nil
ELISP&gt;


ELISP&gt; (symbol-name 'func)
&quot;func&quot;

ELISP&gt; (symbol-value 'func)
    ** Eval error **  Symbol's value as variable is void: func
ELISP&gt; (symbol-function 'func)
(lambda
  (x y)
  (+
   (* 3 x)
   (* 4 y)))

ELISP&gt; (symbol-plist 'func)
nil
ELISP&gt;

;;; Function Source Code

ELISP&gt; (symbol-function #'func)
(lambda
  (x y)
  (+
   (* 3 x)
   (* 4 y)))


;; Test if function is an elisp primitive

ELISP&gt; (subrp (symbol-function 'goto-char))
t
ELISP&gt;
</code></pre>
<h2 id="ç±»å‹è½¬æ¢">ç±»å‹è½¬æ¢</h2>
<p><strong>ç±»å‹æŸ¥è¯¢</strong></p>
<pre><code>ELISP&gt; (type-of 1000)
integer

ELISP&gt; (type-of 1000.3434)
float
ELISP&gt;

ELISP&gt; (type-of &quot;lisp&quot;)
string

ELISP&gt; (type-of '(1 2 3 4 5))
cons
ELISP&gt; (type-of (list 'cos 'sin 1 2 3 4 5))
cons
ELISP&gt;

ELISP&gt; (type-of [1 2 3 4])
vector

ELISP&gt; (type-of 'elisp-mode-map)
symbol
ELISP&gt;

ELISP&gt; (type-of #'cos)
symbol
ELISP&gt;
</code></pre>
<p><strong>ç±»å‹åˆ¤æ–­</strong></p>
<pre><code>;; Test if it is a number
;;-----------------------------------

ELISP&gt; (numberp 1000)
t
ELISP&gt; (numberp 10e4)
t
ELISP&gt; (numberp '(1 2 3 4))
nil
ELISP&gt; (numberp &quot;hello world&quot;)
nil
ELISP&gt;


;; Test if it is a string
;;-----------------------------------

ELISP&gt; (stringp &quot;Emacs&quot;)
t
ELISP&gt; (stringp '(1 2 3 4))
nil
ELISP&gt;

;; Test if ti is a symbol
;;------------------------------------
ELISP&gt; (symbolp 'emacs)
t
ELISP&gt; (symbolp #'emacs)
t
ELISP&gt; (symbolp &quot;something&quot;)
nil
ELISP&gt; (symbolp 10000)
nil
ELISP&gt;


;; Test if it is a list
;;-----------------------------------

ELISP&gt; (listp '(1 2 3 4))
t
ELISP&gt; (listp [1 2 3 4])
nil
ELISP&gt; (listp &quot;hello world&quot;)
nil
ELISP&gt;


;; Test if it is a vector
;;-----------------------------------

ELISP&gt; (vectorp [&quot;Lisp&quot; &quot;Emacs&quot; &quot;Scheme&quot; &quot;Clojure&quot;])
t
ELISP&gt;
ELISP&gt; (vectorp '(1 2 3))
nil
ELISP&gt; (vectorp &quot;lisp&quot;)
nil
ELISP&gt;
</code></pre>
<p><strong>æ•°å­—/å­—ç¬¦ä¸²è½¬æ¢</strong></p>
<pre><code>ELISP&gt;
ELISP&gt; (number-to-string 1000)
&quot;1000&quot;

ELISP&gt; (string-to-number &quot;200&quot;)
200
ELISP&gt;
ELISP&gt;
</code></pre>
<p><strong>ç¬¦å·/å­—ç¬¦ä¸²è½¬æ¢</strong></p>
<pre><code>ELISP&gt; (symbol-name 'my-symbol)
&quot;my-symbol&quot;

ELISP&gt; (symbol-name :my-symbol)
&quot;:my-symbol&quot;
ELISP&gt;

ELISP&gt; (intern &quot;some-symbol&quot;)
some-symbol
</code></pre>
<p><strong>Sè¡¨è¾¾å¼/å­—ç¬¦ä¸²è½¬æ¢</strong></p>
<ul>
<li>
<p>read: è§£æSè¡¨è¾¾å¼</p>
<pre><code>ELISP&gt;
    ELISP&gt; (setq raw &quot;(:x 10 :y 20 :z 30 :w \&quot;hello world\&quot;)&quot;)
    &quot;(:x 10 :y 20 :z 30 :w \&quot;hello world\&quot;)&quot;
    ELISP&gt;
    ELISP&gt; (read raw)
    (:x 10 :y 20 :z 30 :w &quot;hello world&quot;)

    ELISP&gt; (plist-get (read raw) :x)
    10
    ELISP&gt; (plist-get (read raw) :w)
    &quot;hello world&quot;
    ELISP&gt;

-   prin1-to-string: åºåˆ—åŒ–Sè¡¨è¾¾å¼

    ELISP&gt; (setq sexp '(:x 10 :y 20 :z 30 :w &quot;hello world&quot;))
    (:x 10 :y 20 :z 30 :w &quot;hello world&quot;)

    ELISP&gt; sexp
    (:x 10 :y 20 :z 30 :w &quot;hello world&quot;)

    ELISP&gt; (prin1-to-string sexp)
    &quot;(:x 10 :y 20 :z 30 :w \&quot;hello world\&quot;)&quot;
    ELISP&gt;
</code></pre>
</li>
</ul>
<h2 id="æ±‚å€¼">æ±‚å€¼</h2>
<p><strong>Sè¡¨è¾¾å¼æ±‚å€¼</strong></p>
<pre><code>ELISP&gt; (eval '(+ 1 2 3 4 5))
15
ELISP&gt;


ELISP&gt; '(defun func1(x)(* 10 x))
(defun func1
    (x)
  (* 10 x))

ELISP&gt;

ELISP&gt; '((+ 1 3) (* 4 5) (- 8 9))
((+ 1 3)
 (* 4 5)
 (- 8 9))

ELISP&gt; (eval '(defun func1(x)(* 10 x)))
func1
ELISP&gt; (func1 5)
50
ELISP&gt;


ELISP&gt; (mapcar 'eval '((+ 1 3) (* 4 5) (- 8 9)))
(4 20 -1)
</code></pre>
<p><strong>å­—ç¬¦ä¸²æ±‚å€¼</strong></p>
<pre><code>ELISP&gt; (defun eval-string (str) (eval (read str)))
eval-string

ELISP&gt; (eval-string &quot;(+ 1 2 3 4 5 6)&quot;)
21
ELISP&gt;

ELISP&gt; (eval-string &quot;(defun func2(x)(* 10 x)))&quot;)
func2
ELISP&gt; (func2 6)
60
ELISP&gt;
</code></pre>
<p><strong>Sè¡¨è¾¾å¼æ ¼å¼åŒ–ä¸ºå­—ç¬¦ä¸²</strong></p>
<pre><code>ELISP&gt; (setq sexp1 '(+ 1 (* 2 3)))
(+ 1
   (* 2 3))

ELISP&gt; (eval sexp1)
7

ELISP&gt; (format &quot;%S&quot; sexp1)
&quot;(+ 1 (* 2 3))&quot;
ELISP&gt;
</code></pre>
<p><strong>Elispä¸­çš„æ±‚å€¼å‘½ä»¤</strong></p>
<table>
<colgroup>
<col  class="org-left">
<col  class="org-left">
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">å‘½ä»¤</th>
<th scope="col" class="org-left">åŠŸèƒ½</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">M-x eval-defun</td>
<td class="org-left">å‡½æ•°æ±‚å€¼</td>
</tr>
<tr>
<td class="org-left">M-x eval-region</td>
<td class="org-left">åŒºåŸŸå†…è¡¨è¾¾å¼æ±‚å€¼</td>
</tr>
<tr>
<td class="org-left">M-x eval-buffer</td>
<td class="org-left">bufferå†…è¡¨è¾¾å¼æ±‚å€¼</td>
</tr>
<tr>
<td class="org-left">M-x eval-expression</td>
<td class="org-left">è¾“å…¥æ¡†è¾“å…¥æ±‚å€¼</td>
</tr>
<tr>
<td class="org-left">M-x load-file</td>
<td class="org-left">æ–‡ä»¶åŠ è½½</td>
</tr>
</tbody>
</table>
<h2 id="defalias">Defalias</h2>
<p>å†…ç½®å® <code>defalias</code> å¯ä»¥ä¸ºemacaå‡½æ•°å®šä¹‰ç®€çŸ­çš„åå­—ã€‚</p>
<p>å‚è€ƒï¼š<a href="http://ergoemacs.org/emacs/emacs_alias.html">Emacs: Use Alias for Fast M-x</a></p>
<pre><code>ELISP&gt; (require 'cl)
cl
ELISP&gt;

ELISP&gt; (defalias 'map 'mapcar)
map
ELISP&gt; (map (lambda (x) (* 3 x)) (list 1 2 3 4 5 6))
(3 6 9 12 15 18)

ELISP&gt; (defalias 'filter 'remove-if-not) ;; remove-if-not comes from &quot;cl&quot; library
filter

;;; Filter all buffers bounded to a file
;;
ELISP&gt; (filter #'buffer-file-name (buffer-list))
(#&lt;buffer README.org&gt; #&lt;buffer Projects.wiki.org&gt; #&lt;buffer Index.wiki.org&gt; #&lt;buffer settings.org&gt; #&lt;buffer project.org&gt;)

;;; Reject all buffers which are not bounded to a file
ELISP&gt; (reject #'buffer-file-name (buffer-list))
(#&lt;buffer *ielm*&gt; #&lt;buffer *Help*&gt; #&lt;buffer  *Minibuf-1*&gt; #&lt;buffer emacs&gt; #&lt;buffer *scratch*&gt; ..)

;;; The command M-x org-html-export-to-htm will export this document (README.org) to html
;;  the command M-x org2html will do so too.
;;
(defalias #'org2html #'org-html-export-to-html)

;;
;;  It is also useful to create more convenient names for Emacs API
;; in a namsepace-like fashion that makes easier to find functions and
;; autocomplete functions, for instance:
;;
(defalias 'file/extension         'file-name-extension)
(defalias 'file/extension-sans    'file-name-sans-extension)
(defalias 'file/path-expand       'expand-file-name)
(defalias 'file/filename          'file-name-nondirectory)
(defalias 'file/path-relative     'file-relative-name)
(defalias 'file/rename            'rename-file)
(defalias 'file/delete            'delete-file)
(defalias 'file/copy              'copy-file)

;;; To find the documentation of a function group defined in this fashion
;; Enter M-x apropos  and then type file/
(apropos &quot;file/&quot;)

ELISP&gt; (set-buffer &quot;README.org&quot;)
#&lt;buffer README.org&gt;
ELISP&gt; (buffer-file-name)
&quot;/home/tux/PycharmProjects/emacs/README.org&quot;
ELISP&gt; (file/basename (buffer-file-name))
&quot;README&quot;
ELISP&gt; (file/extension (buffer-file-name))
&quot;org&quot;
ELISP&gt; (file/filename (buffer-file-name))
&quot;README.org&quot;
ELISP&gt;
</code></pre>
<h2 id="æ§åˆ¶ç»“æ„">æ§åˆ¶ç»“æ„</h2>
<h3 id="conditional-statement">Conditional Statement</h3>
<p><strong>If Else è¯­å¥</strong></p>
<pre><code>;;
;; Any value different from nil or '() is true, otherwise false.
;;

;; True
;;
ELISP&gt; (if t 5 6)
5

ELISP&gt; (if 10 5 6)
5

ELISP&gt; (if 0 5 6)
5

;; False
ELISP&gt; (if nil 5 6)
6

ELISP&gt; (if '() 5 6)
6


;; Inverting Predicate
;;
ELISP&gt; (if (not t) 5 6)
6

ELISP&gt; (if (not nil) 5 6)
5


ELISP&gt; (if (&lt; 5 10)  (message &quot;less than 10&quot;) (message &quot;greater or equal to 10&quot;) )
&quot;less than 10&quot;

ELISP&gt; (if (&lt; 30 10)  (message &quot;less than 10&quot;) (message &quot;greater or equal to 10&quot;) )
&quot;greater or equal to 10&quot;
ELISP&gt;

;;; If else with multiple statements

ELISP&gt; (setq x 10)
10

ELISP&gt; (if (&gt; x 5)
       ;; Then Statement
       (progn

     (message &quot;Positive Number&quot;)
     (print &quot;Greater than five&quot;)
     (split-window-vertically)
     78 ;;  Return Value
	)
     ;; Else Statement
     (progn
       (print &quot;Less than five&quot;)
       (split-window-horizontally)
       12 ;;  Return Value
     ))

&quot;Greater than five&quot;

78
ELISP&gt;
</code></pre>
<p><strong>Whenè¯­å¥</strong></p>
<pre><code>ELISP&gt; (when t 3)
3

ELISP&gt; (when nil 3)
nil


ELISP&gt; (setq x 5)
5

ELISP&gt; (when (&gt; x 3)
     (message &quot;Less than 3&quot;))
&quot;Less than 3&quot;
ELISP&gt;

ELISP&gt; (setq x 1)
1

ELISP&gt; (when (&gt; x 3)
     (message &quot;Less than 3&quot;))
nil
ELISP&gt;


;;;;; When with Multiple Statements

ELISP&gt; (setq x 10)
10

ELISP&gt; (when (&gt; x 7)
     (progn
       (message &quot;Greater than 7 OK.&quot;)
       (message &quot;Print message 2&quot;)
       (split-window-horizontally)
      ))

 #&lt;window 8 on *ielm*&gt;
ELISP&gt;
</code></pre>
<h3 id="cond---case-switch">Cond - Case Switch</h3>
<pre><code>ELISP&gt; (setq a 3)       ;; a = 3
3
ELISP&gt;

ELISP&gt; (cond
	((evenp a) a)       ;; if   (a % 2 == 0)    ==&gt; a
	((&gt; a 7) (/ a 2))   ;; elif (a &gt; 7)         ==&gt; a/2
	((&lt; a 5) (- a 1))   ;; elif (a &lt; 5)         ==&gt; a-1
	(t 7)               ;; else                 ==&gt; 7
	)
2
ELISP&gt;
</code></pre>
<h3 id="cl-case---case-switch">CL-Case - Case Switch</h3>
<pre><code>(defun test-cl-case (operation x y)
  (cl-case operation
    (:mul (* x y))
    (:add (+ x y))
    (:sub (- x y))
    (:div (/ x y))
    (otherwise nil)))

ELISP&gt; (test-cl-case :mul 2 10)
20

ELISP&gt; (test-cl-case :sub 10 2)
8

ELISP&gt; (test-cl-case :add 10 2)
12
ELISP&gt; (test-cl-case :div 10 2)
5

ELISP&gt; (test-cl-case 'dummy 20 10)
nil
</code></pre>
<h3 id="å¾ªç¯">å¾ªç¯</h3>
<p><strong>Dolist</strong></p>
<pre><code>ELISP&gt; (dolist (h '(a b c)) (print h))

a

b

c

nil

ELISP&gt; (dolist (x '(1 2 3)) (print (* 2 x)))

2

4

6

nil
ELISP&gt;

ELISP&gt; (dolist (x '(1 2 3))
     (dolist (y '(a b))
        (print (list x y))))
(1 a)

(1 b)

(2 a)

(2 b)

(3 a)

(3 b)

nil
ELISP&gt;
</code></pre>
<p><strong>Dotimes</strong></p>
<pre><code>ELISP&gt; (dotimes (i 3) (print i))

0

1

2

nil
ELISP

ELISP&gt; (dotimes (i 3) (print (* 2 i)))

0

2

4

nil
ELISP&gt;
</code></pre>
<p><strong>Loop</strong></p>
<p>æœ€å¥½ä½¿ç”¨ <code>map</code> å’Œ <code>filter</code> ä»£æ›¿ <code>loops</code> , è¯¦è§ Functional Programming</p>
<pre><code>ELISP&gt; (setq a 4)
4

ELISP&gt; (loop
	(setq a (+ a 1))
	(when (&gt; a 7) (return a)))
8

ELISP&gt; a
8
ELISP&gt;

ELISP&gt; (loop
   (setq a (- a 1))
   (when (&lt; a 3) (return)))
nil
ELISP&gt; a
2
ELISP&gt;
</code></pre>
<p><strong>Loop Collecting / Summing / For</strong></p>
<pre><code>ELISP&gt; (loop for i from 1 to 10 collecting i)
(1 2 3 4 5 6 7 8 9 10)

ELISP&gt; (loop for i from 1 to 10 collecting (* 3 i))
(3 6 9 12 15 18 21 24 27 30)

ELISP&gt; (loop for x from 1 to 10 summing (expt x 2))
385

ELISP&gt; (loop for x from 1 to 10 collecting (* 2 x))
(2 4 6 8 10 12 14 16 18 20)

ELISP&gt; (loop for x from 1 to 10 summing (* 2 x))
110
ELISP&gt;

ELISP&gt; (apply #'+ '(2 4 6 8 10 12 14 16 18 20))
110

ELISP&gt; (loop for i below 10 collecting i)
(0 1 2 3 4 5 6 7 8 9)

ELISP&gt;  (loop for x in '(1 2 3)
      do (print x) )

1

2

3

nil

(loop
       for x in '(a b c)
       for y in '(1 2 3 4 5 6)
       collect (list x y))
((a 1)
 (b 2)
 (c 3))

ELISP&gt; (loop for (a b) in '((x 1) (y 2) (z 3))
      collect (list b a))
((1 x)
 (2 y)
 (3 z))

ELISP&gt; (loop for i upto 20
      if (oddp i)
	collect i into odds
      else
	collect i into evens
      finally (return (values evens odds)))
((0 2 4 6 8 10 12 14 16 18 20)
 (1 3 5 7 9 11 13 15 17 19))
</code></pre>
<p><strong>Do Loop</strong></p>
<pre><code>(do (variable-definition*)
    (end-test-form result-form*)
  statement*)

(do
   ;; Variables Definitions
   ((i 0 (1+ i)))

   ;; Test form
    ((&gt;= i 4))

  ;; Statement form
  (print i))

0

1

2

3
nil

;; Fibbonaci Computing Loop
;;
(do ((n 0 (1+ n))
     (cur 0 next)
     (next 1 (+ cur next)))
    ((= 10 n) cur))
55
</code></pre>
<h3 id="å‡½æ•°å¼ç¼–ç¨‹">å‡½æ•°å¼ç¼–ç¨‹</h3>
<p><a href="https://github.com/magnars/dash.el.git">Dash</a> æ˜¯emacsç»å¸¸ä½¿ç”¨çš„å‡½æ•°å¼ç¼–ç¨‹åº“ã€‚</p>
<ul>
<li>Map and Filter</li>
</ul>
<p><strong>Mapcar / Equivalent to map</strong></p>
<pre><code>ELISP&gt; (defun my-fun (x) (* x 10))
my-fun
ELISP&gt;

ELISP&gt; (mapcar 'my-fun '(1 2 3 5 6))
(10 20 30 50 60)

ELISP&gt; (mapcar 'capitalize '(&quot;hello&quot; &quot;world&quot; &quot;emacs&quot;))
(&quot;Hello&quot; &quot;World&quot; &quot;Emacs&quot;)

;;  Anonymous Functions
;;
ELISP&gt; (mapcar (lambda (x) (* x x))   '(1 2 3 4 5 6))
(1 4 9 16 25 36)


ELISP&gt; (setq anon (lambda (x) (* x x)))
(lambda
  (x)
  (* x x))

ELISP&gt; (mapcar anon '(1 2 3 4 5 6))
(1 4 9 16 25 36)
</code></pre>
<p><strong>Filter</strong></p>
<pre><code>ELISP&gt; (null nil)
t
ELISP&gt; (null 23)
nil
ELISP&gt;

;; Equivalent to  Haskell idiom:
;;
;; &gt; filter predicate list
;;
ELISP&gt; (remove-if-not 'null '(1 2 3 nil 5 6 nil nil ))
(nil nil nil)

;; Equivalent to Haskell idiom:
;;
;;   &gt; filter (\x -&gt; not (predicate x)) list
;;
;; a more apropriate name would be reject
;;
ELISP&gt; (remove-if 'null '(1 2 3 nil 5 6 nil nil ))
(1 2 3 5 6)



ELISP&gt; (defun range (step start stop)
  (if (&gt; start stop)
      nil
      (cons start (range step (+ step start) stop))

  );; End If
);; End range

ELISP&gt; (range 1 0 10)
(0 1 2 3 4 5 6 7 8 9 10)

ELISP&gt; (range 2 0 20)
(0 2 4 6 8 10 12 14 16 18 20)


ELISP&gt; (remove-if (lambda (x) (= (% x 2) 0)) (range 1 0 20))
(1 3 5 7 9 11 13 15 17 19)

ELISP&gt; (remove-if-not (lambda (x) (= (% x 2) 0)) (range 1 0 20))
(0 2 4 6 8 10 12 14 16 18 20)


ELISP&gt; (remove-if (lambda (x) (= (% x 3) 0)) (range 1 0 20))
(1 2 4 5 7 8 10 11 13 14 16 17 19 20)

ELISP&gt; (remove-if-not (lambda (x) (= (% x 3) 0)) (range 1 0 20))
(0 3 6 9 12 15 18)

ELISP&gt;
</code></pre>
<ul>
<li>
<p>åŒ¿åå‡½æ•°/lambdaå‡½æ•°</p>
<pre><code>ELISP&gt; (lambda (x)(* x 10))
    (lambda
      (x)
      (* x 10))

    ELISP&gt;

    ELISP&gt; (funcall (lambda (x)(* x 10)) 5)
    50
    ELISP&gt;

    ELISP&gt; (setq my-lambda (lambda (x) (+ (* x 10) 5))) ;; 10 * x + 5
    (lambda
      (x)
      (+
       (* x 10)
       5))

    ELISP&gt; (funcall my-lambda 10)
    105
    ELISP&gt; (mapcar my-lambda '(1 2 3 4 5))
    (15 25 35 45 55)


    ELISP&gt;  (setq double (function (lambda (x) (+ x x)) ))
    (lambda
      (x)
      (+ x x))

    ELISP&gt; (funcall double 22)
    44
    ELISP&gt;


    ;;
    ;; Apply a function to a list of arguments
    ;;
    ;;;;;;;;;;;

    ELISP&gt; (apply #'+ '(1 2 3 4 5))
    15
    ELISP&gt;

    ELISP&gt;
    ELISP&gt; (defun f (x y z) (+ (* 10 x) (* -4 y) (* 5 z)))
    f
    ELISP&gt; (f 2 3 5)
    33

    ELISP&gt; (apply 'f '(2 3 5))
    33


    ELISP&gt; (mapcar (lambda (x) (apply 'f x)) '( (2 3 5) (4 5 6) (8 9 5)))
    (33 50 69)



    ;; Create Higher Order Functions
    ;;
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
</code></pre>
</li>
<li>
<p>Function Composition ????</p>
<pre><code>ELISP&gt; ;; ID: f0c736a9-afec-3e3f-455c-40997023e130
    (defun compose (&amp;rest funs)
      &quot;Return function composed of FUNS.&quot;
      (lexical-let ((lex-funs funs))
        (lambda (&amp;rest args)
          (reduce 'funcall (butlast lex-funs)
              :from-end t
              :initial-value (apply (car (last lex-funs)) args)))))
              compose

    ELISP&gt; (funcall (compose 'prin1-to-string 'random* 'exp) 10)
    &quot;4757.245739507558&quot;
    ELISP&gt;
</code></pre>
</li>
<li>
<p>Interactive Functions</p>
<pre><code>(defun some-interactive-function ()
       &quot;Documentation&quot;
      (interactive)
      ...)
</code></pre>
</li>
<li>
<p>List Recursive Functions</p>
</li>
</ul>
<p><strong>Map</strong></p>
<pre><code>(defun map (fun xs)
  (if (null xs)
      '()
    (cons (funcall fun (car xs))
      (map fun (cdr xs)))))

ELISP&gt; (map #'buffer-name (buffer-list))
(&quot;*ielm*&quot; &quot;*scratch*&quot; &quot; *Minibuf-1*&quot; &quot;*Backtrace*&quot; &quot;*eshell*&quot; &quot;sclj.import.scm&quot; &quot;*Messages*&quot; &quot;*GNU Emacs*&quot; &quot; *Minibuf-0*&quot; &quot; *code-conversion-work*&quot; &quot; *Echo Area 0*&quot; &quot; *Echo Area 1*&quot; &quot;*Shell Command Output*&quot; &quot;*Completions*&quot;)

ELISP&gt;
</code></pre>
<p><strong>Filter</strong></p>
<pre><code>(defun filter (fun xs)
  (if (null xs)
      '()
    (let ((hd (car xs))
      (tl (cdr xs)))
      (if (funcall fun hd)
      (cons hd (filter fun tl))
    (filter fun tl)))))

(defun odd? (x) (zerop (% x 2)))

ELISP&gt; (filter #'odd? '(1 2 3 4 5 6))
(2 4 6)
</code></pre>
<p><strong>Take</strong></p>
<pre><code>(defun take (n xs)
  (if (or (null xs) (zerop n))
      '()
    (cons (car xs)
          (take (- n 1) (cdr xs)))))


ELISP&gt; (take 5 '(a b c d e f g h i j))
(a b c d e)

ELISP&gt; (take 10 '(a b c d e f g h i j))
(a b c d e f g h i j)

ELISP&gt; (take 200 '(a b c d e f g h i j))
(a b c d e f g h i j)

ELISP&gt; (take 0 '(a b c d e f g h i j))
nil
ELISP&gt; (take 10 '())
nil
ELISP&gt;
</code></pre>
<p><strong>Drop</strong></p>
<pre><code>(defun drop (n xs)
  (if (or (null xs) (zerop n))
      xs
    (drop (- n 1)  (cdr xs))))

ELISP&gt; (drop 3 '(a b c d e f g h i j))
(d e f g h i j)

ELISP&gt; (drop 4 '(a b c d e f g h i j))
(e f g h i j)

ELISP&gt; (drop 25 '(a b c d e f g h i j))
nil
ELISP&gt;
</code></pre>
<p><strong>Map-apply</strong></p>
<pre><code>(defun map-apply (fun xss)
  (mapcar (lambda (xs) (apply fun xs)) xss))

ELISP&gt; (map-apply #'fxyz '((1 2 3) (3 4 5) (2 3 1)))
(17 35 20)

ELISP&gt; (fxyz 1 2 3)
17
ELISP&gt; (fxyz 3 4 5)
35
ELISP&gt; (fxyz 2 3 1)
20
ELISP&gt;
</code></pre>
<p><strong>Zip</strong></p>
<pre><code>(defun zip (&amp;rest xss)
  (if (null (car xss))
      '()
    (cons
     (mapcar #'car xss)
     (apply #'zip (mapcar #'cdr xss)))))

ELISP&gt; (zip (list 1 2 3 4) '(a b c d) '(x y z w))
((1 a x)
 (2 b y)
 (3 c z)
 (4 d w))
</code></pre>
<p><strong>Zipwith</strong></p>
<pre><code>(defun zipwith (f &amp;rest xss)
  (map-apply f (apply #'zip xss)))

ELISP&gt; (zipwith #'f '(1 2 3) '(4 5 6) '(3 6 8))
(23 40 53)

ELISP&gt; (f 1 4 3)
23

ELISP&gt; (f 2 5 6)
40

ELISP&gt; (f 3 6 8)
53
ELISP&gt;
</code></pre>
<p><strong>Foldr</strong></p>
<pre><code>;;           f :: x -&gt; acc -&gt; acc
;; foldr :: (a -&gt; b -&gt; b) -&gt; b -&gt; [a] -&gt; b
;; foldr :: (x -&gt; acc -&gt; acc) -&gt; acc -&gt; [x] -&gt; acc
;; foldr f z []     = z
;; foldr f z (x:xs) = f x (foldr f z xs)
;;
;;  x = (car xss) , xs = (cdr xss)
(defun foldr (f acc xss)
  (if (null xss)
      ;; foldr f z []     = z
      acc
    ;; foldr f z (x:xs) = f x (foldr f z xs)
    (funcall f (car xss)
             (foldr f acc (cdr xss)))))

ELISP&gt; (foldr (lambda (a b) (+ (* 10 b) a)) 0 '(1 2 3 4 5))
54321
ELISP&gt;

ELISP&gt; (foldr #'+ 0 '(1 2 3 4 5))
15
ELISP&gt;
</code></pre>
<p><strong>Foldl</strong></p>
<pre><code>;; foldl :: (b -&gt; a -&gt; b) -&gt; b -&gt; [a] -&gt; b
;; foldl f z []     = z
;; foldl f z (x:xs) = foldl f (f z x) xs
(defun foldl (f acc xss)
  (if (null xss)
      acc
    (foldl f (funcall f acc (car xss)) (cdr xss))))

ELISP&gt; (foldl (lambda (a b) (+ (* 10 a) b)) 0 '(1 2 3 4 5))
12345
ELISP&gt;
</code></pre>
<p><strong>Map Pairs</strong></p>
<pre><code>(defun map-pair (func xs)
  (mapcar (lambda (x) (cons x (funcall func x))) xs))

ELISP&gt; (map-pair #'1+ '(1 2 3 4))
((1 . 2)
 (2 . 3)
 (3 . 4)
 (4 . 5))

ELISP&gt; (map-pair #'log10 '(1 10 100 1000 10000))
((1 . 0.0)
 (10 . 1.0)
 (100 . 2.0)
 (1000 . 3.0)
 (10000 . 4.0))

(defun buffer-mode (buffer-or-string)
  &quot;Returns the major mode associated with a buffer.&quot;
  (with-current-buffer buffer-or-string
    major-mode))

ELISP&gt; (map-pair #'buffer-mode (buffer-list))
((#&lt;buffer *ielm*&gt; . inferior-emacs-lisp-mode)
 (#&lt;buffer *scratch*&gt; . lisp-interaction-mode)
 (#&lt;buffer *Backtrace*&gt; . debugger-mode)
 (#&lt;buffer *GNU Emacs*&gt; . fundamental-mode)
 (#&lt;buffer  *Minibuf-1*&gt; . minibuffer-inactive-mode)
 (#&lt;buffer  *Minibuf-0*&gt; . minibuffer-inactive-mode)
 (#&lt;buffer *Messages*&gt; . messages-buffer-mode)
</code></pre>
<p><strong>Map pairs xy</strong></p>
<pre><code>(defun map-xypair (func-x func-y xs)
  (mapcar
   (lambda (x)
     (cons (funcall func-x x) (funcall func-y x)))
   xs))

ELISP&gt; (map-xypair #'buffer-name #'buffer-mode (buffer-list))
((&quot;*ielm*&quot; . inferior-emacs-lisp-mode)
 (&quot;*scratch*&quot; . lisp-interaction-mode)
 (&quot;*Backtrace*&quot; . debugger-mode)
 (&quot;*GNU Emacs*&quot; . fundamental-mode)
 (&quot; *Minibuf-1*&quot; . minibuffer-inactive-mode)
 (&quot; *Minibuf-0*&quot; . minibuffer-inactive-mode)
 (&quot;*Messages*&quot; . messages-buffer-mode)
 (&quot; *code-conversion-work*&quot; . fundamental-mode)
 (&quot; *Echo Area 0*&quot; . fundamental-mode)
 (&quot; *Echo Area 1*&quot; . fundamental-mode)
 (&quot; *http www.httpbin.org:80*&quot; . fundamental-mode)
 (&quot; *http www.httpbin.org:80*-820734&quot; . fundamental-mode)
 (&quot; *http www.httpbin.org:80*-914099&quot; . fundamental-mode)
 (&quot; *http www.httpbin.org:80*-945998&quot; . fundamental-mode)
 (&quot;*Help*&quot; . help-mode)
 (&quot;*Completions*&quot; . completion-list-mode))
</code></pre>
<p><strong>Juxt</strong></p>
<pre><code>ELISP&gt; (juxt #'buffer-name #'buffer-mode)
(lambda
  (x)
  (list
   ((funcall #'buffer-name x)
    (funcall #'buffer-mode x))))


ELISP&gt; (funcall (juxt #'buffer-file-name  #'buffer-name #'buffer-mode) (current-buffer))
(nil &quot;*ielm*&quot; inferior-emacs-lisp-mode)

ELISP&gt; (mapcar (juxt #'buffer-name #'buffer-file-name #'buffer-mode) (buffer-list))
((&quot;*ielm*&quot; nil inferior-emacs-lisp-mode)
 (&quot;*scratch*&quot; nil lisp-interaction-mode)
 (&quot;passgen.py&quot; &quot;/home/tux/bin/passgen.py&quot; python-mode)
 (&quot;.bashrc&quot; &quot;/home/tux/.bashrc&quot; sh-mode)
 (&quot; *Minibuf-1*&quot; nil minibuffer-inactive-mode)
 (&quot;init.el&quot; &quot;/home/tux/.emacs.d/init.el&quot; emacs-lisp-mode)
 (&quot;*Backtrace*&quot; nil debugger-mode)
 (&quot;*GNU Emacs*&quot; nil fundamental-mode)
 (&quot; *Minibuf-0*&quot; nil minibuffer-inactive-mode)
 (&quot;*Messages*&quot; nil messages-buffer-mode)
 (&quot; *code-conversion-work*&quot; nil fundamental-mode)
 (&quot; *Echo Area 0*&quot; nil fundamental-mode)
 (&quot; *Echo Area 1*&quot; nil fundamental-mode)
 (&quot; *http www.httpbin.org:80*&quot; nil fundamental-mode)
 (&quot; *http www.httpbin.org:80*-820734&quot; nil fundamental-mode)
 (&quot; *http www.httpbin.org:80*-914099&quot; nil fundamental-mode)
 (&quot; *http www.httpbin.org:80*-945998&quot; nil fundamental-mode)
 (&quot;*Help*&quot; nil help-mode)
 (&quot;*Completions*&quot; nil completion-list-mode))
</code></pre>
<p><strong>Map Juxt</strong></p>
<pre><code>(defmacro map-juxt (xs_f xs)
  `(mapcar (juxt ,@xs_f) ,xs))


ELISP&gt; (map-juxt (#'buffer-name #'buffer-file-name #'buffer-mode) (buffer-list))
((&quot;*ielm*&quot; nil inferior-emacs-lisp-mode)
 (&quot;*scratch*&quot; nil lisp-interaction-mode)
 (&quot;passgen.py&quot; &quot;/home/tux/bin/passgen.py&quot; python-mode)
 (&quot;.bashrc&quot; &quot;/home/tux/.bashrc&quot; sh-mode)
 (&quot; *Minibuf-1*&quot; nil minibuffer-inactive-mode)
 (&quot;init.el&quot; &quot;/home/tux/.emacs.d/init.el&quot; emacs-lisp-mode)
 (&quot;*Backtrace*&quot; nil debugger-mode)
 (&quot;*GNU Emacs*&quot; nil fundamental-mode)
 (&quot; *Minibuf-0*&quot; nil minibuffer-inactive-mode)
 (&quot;*Messages*&quot; nil messages-buffer-mode)
 ...
</code></pre>
<p><strong>Lambda Function Macro</strong></p>
<pre><code>(defmacro $f (f &amp;rest params)
  `(lambda ($) (,f ,@params)))


ELISP&gt; ($f - 10 $)
(lambda
  ($)
  (- 10 $))

ELISP&gt; ($f * (+ 3 $) 5)
(lambda
  ($)
  (*
   (+ 3 $)
   5))

ELISP&gt; (funcall ($f * (+ 3 $) 5) 10)
65
ELISP&gt; (mapcar  ($f * (+ 3 $) 5) '(1 2 3 4 5))
(20 25 30 35 40)

ELISP&gt;
ELISP&gt; (mapcar  ($f list (1+ $) (1- $) (log10 $)) '(1 10 100 1000))
((2 0 0.0)
 (11 9 1.0)
 (101 99 2.0)
 (1001 999 3.0))
</code></pre>
<p><strong>Partial Application</strong></p>
<pre><code>(defmacro $c (f  &amp;rest params)
  `(lambda (__x) (,f ,@params __x)))

ELISP&gt; (defun f (x y z) (+ (* 3 x) (* 2 y) (* 4 z)))
f
ELISP&gt; (f 1 2 3)
19
ELISP&gt; ($c f 1 2)
(lambda
  (__x)
  (f 1 2 __x))

ELISP&gt; (mapcar ($c f 1 2) '(1 2 3 4 5))
(11 15 19 23 27)

ELISP&gt; (mapcar ($c + 1 2) '(1 2 3 4 5))
(4 5 6 7 8)

ELISP&gt;
</code></pre>
<h2 id="structures">Structures</h2>
<pre><code>ELISP&gt; (defstruct account id name balance)
account
ELISP&gt; (make-account :id 3434 :name &quot;John&quot; :balance 1000.34)
[cl-struct-account 3434 &quot;John&quot; 1000.34]

ELISP&gt; (setq user1 (make-account :id 3434 :name &quot;John&quot; :balance 1000.34))
[cl-struct-account 3434 &quot;John&quot; 1000.34]

ELISP&gt; (account-name user1)
&quot;John&quot;

ELISP&gt; (account-id user1)
3434

ELISP&gt; (account-balance user1)
1000.34

;; Test if input is an account object
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
ELISP&gt; (account-p user1)
t
ELISP&gt;

;; Change Field
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

ELISP&gt; (defun withdraw (accc amount)
         (setf (account-balance acc) (- (account-balance acc) amount)))
withdraw

ELISP&gt; (withdraw user1 300)
700.34
ELISP&gt; user1
[cl-struct-account 3434 &quot;John&quot; 700.34]

ELISP&gt; (withdraw user1 500)
200.34000000000003
ELISP&gt; user1
[cl-struct-account 3434 &quot;John&quot; 200.34000000000003]

ELISP&gt;

;; Build structure from a list of parameters
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

ELISP&gt; (defun build-account (id name balance)
         (make-account :id id :name name  :balance balance))
build-account

ELISP&gt; (build-account 3434 &quot;O' Neil&quot; 35434.23)
[cl-struct-account 3434 &quot;O' Neil&quot; 35434.23]

ELISP&gt; (apply 'build-account '(3434 &quot;O' Neil&quot; 35434.23))
[cl-struct-account 3434 &quot;O' Neil&quot; 35434.23]

ELISP&gt;

ELISP&gt; (mapcar (lambda (params) (apply 'build-account params))
               '(
                 (34423 &quot;O' Neil&quot; 23.2323)
                 (1023  &quot;John Edwards&quot; 1002323.23)
                 (92323 &quot;Mr. Dummy&quot;  2323241.2323)
                 (8723  &quot;John Oliver&quot; 9823)
                 ))
([cl-struct-account 34423 &quot;O' Neil&quot; 23.2323]
 [cl-struct-account 1023 &quot;John Edwards&quot; 1002323.23]
 [cl-struct-account 92323 &quot;Mr. Dummy&quot; 2323241.2323]
 [cl-struct-account 8723 &quot;John Oliver&quot; 9823])

ELISP&gt;

ELISP&gt; (defun build-accounts-from-list (list-of-params)
         (mapcar (lambda (params) (apply 'build-account params)) list-of-params))
build-accounts-from-list
ELISP&gt;

ELISP&gt; (setq accounts (build-accounts-from-list
                       '(
                         (34423 &quot;O' Neil&quot; 23.2323)
                         (1023  &quot;John Edwards&quot; 1002323.23)
                         (92323 &quot;Mr. Dummy&quot;  2323241.2323)
                         (8723  &quot;John Oliver&quot; 9823)
                         )))
([cl-struct-account 34423 &quot;O' Neil&quot; 23.2323]
 [cl-struct-account 1023 &quot;John Edwards&quot; 1002323.23]
 [cl-struct-account 92323 &quot;Mr. Dummy&quot; 2323241.2323]
 [cl-struct-account 8723 &quot;John Oliver&quot; 9823])

ELISP&gt; accounts
([cl-struct-account 34423 &quot;O' Neil&quot; 23.2323]
 [cl-struct-account 1023 &quot;John Edwards&quot; 1002323.23]
 [cl-struct-account 92323 &quot;Mr. Dummy&quot; 2323241.2323]
 [cl-struct-account 8723 &quot;John Oliver&quot; 9823])

ELISP&gt; (mapcar #'account-id accounts)
(34423 1023 92323 8723)

ELISP&gt;

ELISP&gt;
ELISP&gt; (mapcar #'account-name accounts)
(&quot;O' Neil&quot; &quot;John Edwards&quot; &quot;Mr. Dummy&quot; &quot;John Oliver&quot;)

ELISP&gt;


ELISP&gt; (mapcar #'account-balance accounts)
(23.2323 1002323.23 2323241.2323 9823)

ELISP&gt;
</code></pre>
<h1 id="å®å’Œå…ƒç¼–ç¨‹">å®å’Œå…ƒç¼–ç¨‹</h1>
<h2 id="quasi-quote">Quasi-quote</h2>
<pre><code>;;;; Quasiquote

&gt; `(the product of 3 and 4 is ,(* 3 4))
(the product of 3 and 4 is 12)

&gt; `(&quot;the product of 3 and 4 is&quot; ,(* 3 4))
(&quot;the product of 3 and 4 is&quot; 12)

&gt; `(&quot;the value of (exp 3) is &quot; ,(exp 3) &quot;the value of (sqrt 100) is&quot; ,(sqrt 100))
(&quot;the value of (exp 3) is &quot; 20.085536923187668 &quot;the value of (sqrt 100) is&quot; 10.0)

&gt; `(a ,a b ,b c ,c d ,d)
(a 10 b 20 c my-symbol d &quot;a string&quot;)

&gt; `((a . ,a) (b . ,b) (c . ,c) (d . ,d))
((a . 10)
 (b . 20)
 (c . my-symbol)
 (d . &quot;a string&quot;))

&gt; (setq xs '(sym1 sym2 sym3))
(sym1 sym2 sym3)

&gt; xs
(sym1 sym2 sym3)

&gt; `(xs ,xs)
(xs
 (sym1 sym2 sym3))

&gt; `(xs ,@xs)
(xs sym1 sym2 sym3)

&gt; `(if (&lt; ,a ,b) ,(+ a 4) ,d)
(if
    (&lt; 10 20)
    14 &quot;a string&quot;)

&gt; (eval `(if (&lt; ,a ,b) ,(+ a 4) ,d))
14
&gt;

&gt; (eval `(if (&gt; ,a ,b) ,(+ a 4) ,d))
&quot;a string&quot;

;;------------------

&gt; (setq xlist '(1 2 3 4))
(1 2 3 4)

&gt; (setq ylist '(a b c d e))
(a b c d e)

&gt; `(xs ,xlist ys ,ylist)
(xs
 (1 2 3 4)
 ys
 (a b c d e))

&gt; `(xs ,@xlist ys ,@ylist)
(xs 1 2 3 4 ys a b c d e)
</code></pre>
<h2 id="å®">å®</h2>
<p><strong>å®šä¹‰lambdaå‡½æ•°è¯­æ³•ç³–:Î»</strong></p>
<pre><code>(defmacro Î» (args body)
  `(lambda ,args ,body))

ELISP&gt; (Î» (x) (+ x 3))
(lambda
  (x)
  (+ x 3))
ELISP&gt; (mapcar (Î» (x) (+ x 3)) '(1 2 3 4 5 6))
(4 5 6 7 8 9)
</code></pre>
<p><strong>Set variable to nil</strong></p>
<pre><code>(defmacro nil! (var)
  `(setq ,var nil))

ELISP&gt; (setq x 10)
10
ELISP&gt; x
10
ELISP&gt;

ELISP&gt; (nil! x)
nil
ELISP&gt; x
nil
ELISP&gt;

ELISP&gt; (nil! z)
nil
ELISP&gt; z
nil
ELISP&gt;
</code></pre>
<p><strong>Create Clojure def, defn and fn special forms</strong></p>
<pre><code>(defmacro fn (args body)
  `(lambda ,args ,body))

(defmacro def (name value)
  `(setq ,name ,value))

(defmacro defn (name args body)
  `(defun ,name ,args ,body))

ELISP&gt; (fn (x) (* x x))
(lambda
  (x)
  (* x x))

ELISP&gt; (mapcar (fn (x) (* x x)) '(1 2 3 4 5))
(1 4 9 16 25)

ELISP&gt; (def x 1000)
1000
ELISP&gt; x
1000
ELISP&gt;

ELISP&gt; (defn f (x y z) (+ (* 3 x) (* -4 y) (* 5 z)))
f
ELISP&gt; (f 4 5 6)
22
ELISP&gt;
</code></pre>
<p>â€¦â€¦</p>
<h1 id="emacs-api">Emacs API</h1>
<h2 id="emacsæœ¯è¯­">Emacsæœ¯è¯­</h2>
<table>
<colgroup>
<col  class="org-left">
<col  class="org-left">
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Emacs Terminology</th>
<th scope="col" class="org-left">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">Point</td>
<td class="org-left">Cursor position, number of characters from beggining of the buffer to current cursor position.</td>
</tr>
<tr>
<td class="org-left">Buffer</td>
<td class="org-left">Place where the user edit something. Not all buffers are bound to a file.</td>
</tr>
<tr>
<td class="org-left">Mark</td>
<td class="org-left">Beginning of the selected area.</td>
</tr>
<tr>
<td class="org-left">Region</td>
<td class="org-left">Selected area/ text</td>
</tr>
<tr>
<td class="org-left">Frame</td>
<td class="org-left">The current window of emacs</td>
</tr>
<tr>
<td class="org-left">Windows</td>
<td class="org-left">Each frame can be split in sections that Emacs documentation calls windows</td>
</tr>
<tr>
<td class="org-left">Fill</td>
<td class="org-left">Word Wrap</td>
</tr>
<tr>
<td class="org-left">Yank</td>
<td class="org-left">Copy</td>
</tr>
<tr>
<td class="org-left">Kill Region</td>
<td class="org-left">Cut</td>
</tr>
<tr>
<td class="org-left">Kill Ring</td>
<td class="org-left">Clipboard</td>
</tr>
<tr>
<td class="org-left">Kill Buffer</td>
<td class="org-left">Close Buffer</td>
</tr>
<tr>
<td class="org-left">Mode Line</td>
<td class="org-left">Status Bar</td>
</tr>
<tr>
<td class="org-left">Font Locking</td>
<td class="org-left">Syntax Coloring</td>
</tr>
</tbody>
</table>
<p><a href="http://www.blogbyben.com/2011/04/10-concepts-emacs-newbie-should-master.html">Ben&rsquo;s Journal: 11 Concepts The Emacs Newbie Should Master</a></p>
<h2 id="emacs-api-1">Emacs API</h2>
<p><strong>APIå¯¹è±¡</strong></p>
<ul>
<li>Buffer</li>
<li>Temporary Buffer</li>
<li>Modes</li>
<li>Mode Hooks</li>
<li>Mode Map</li>
<li>Window</li>
<li>Frame</li>
<li>Point</li>
<li>Process</li>
<li>Network Process</li>
<li>Minibuffers</li>
</ul>
<h2 id="buffers">Buffers</h2>
<h3 id="buffer-attributes">Buffer Attributes</h3>
<pre><code>(buffer-list)
(current-buffer)
(mapcar #'buffer-name (buffer-list))
(mapcar #'buffer-file-name (buffer-list))
(kill-buffer &quot;init.el&quot;)
(get-buffer &quot;*scratch*&quot;)
</code></pre>
<p><strong>åˆ—å‡ºæ‰“å¼€æ–‡ä»¶</strong></p>
<pre><code>(defun opened-files ()
  &quot;list all opened file in current session&quot;
  (interactive)
  (remove-if 'null (mapcar 'buffer-file-name (buffer-list))))

(opened-files)
</code></pre>
<p><strong>åˆ›å»ºæ–°buffer</strong></p>
<pre><code>;;
;;
;; This function returns a buffer named  buffer-or-name.
;; The buffer returned does not become the current
;; bufferâ€”this function does not change which buffer is current.
;;

ELISP&gt; (get-buffer-create &quot;foobar&quot;)
#&lt;buffer foobar&gt;
ELISP&gt;

;;
;;  Divide the screen in two windows, and switch to the new buffer
;;  window
;;
ELISP&gt; (switch-to-buffer-other-window &quot;foobar&quot;)
#&lt;buffer foobar&gt;
ELISP&gt;

;; Clean Current Buffer
;;
ELISP&gt; (erase-buffer)
nil
ELISP&gt;

;;  Edit another buffer and go back to the old buffer
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

ELISP&gt; (defun within-buffer (name function)
         (let (curbuff (current-buffer))
           (switch-to-buffer name)
           (funcall function)
           (switch-to-buffer current-buffer)
           ))

ELISP&gt; (within-buffer &quot;foobar&quot; (lambda () (insert &quot;dummy&quot;)))
#&lt;buffer *ielm*&gt;
ELISP&gt;
ELISP&gt; (lambda (x)(* x 10))
(lambda
  (x)
  (* x 10))

;;;; Translated from: http://d.hatena.ne.jp/rubikitch/20100201/elispsyntax
;;
ELISP&gt; ;; test-buffer Create a buffer named, to write a variety of content
(with-current-buffer (get-buffer-create &quot;test-buffer&quot;)
  ;; Empty the contents of the buffer
  (erase-buffer)
  ;; /tmp/foo.txt Make the contents inserted
  (insert-file-contents &quot;/etc/fstab&quot;)
  ;; Insert a string
  (insert &quot;End\n&quot;)
  ;; Write the contents of a buffer to a file
  (write-region (point-min) (point-max) &quot;/tmp/bar.txt&quot;))
nil
ELISP&gt;
</code></pre>
<h3 id="buffer-mode">Buffer Mode</h3>
<p><strong>Show Buffers Mode</strong></p>
<pre><code>ELISP&gt; (defun buffer-mode (buffer-or-string)
         &quot;Returns the major mode associated with a buffer.&quot;
         (with-current-buffer buffer-or-string
           major-mode))
buffer-mode

ELISP&gt; (mapcar (lambda (b)(
                           let
                           (
                            (name (buffer-name b))
                            (type   (buffer-mode (buffer-name b)))
                            )
                           (list name type)
                           ))
               (buffer-list))
((&quot;*ielm*&quot; inferior-emacs-lisp-mode)
 (&quot;*SPEEDBAR*&quot; speedbar-mode)
 (&quot; *Minibuf-1*&quot; minibuffer-inactive-mode)
 (&quot;*scratch*&quot; emacs-lisp-mode)
 (&quot;test3.ml&quot; tuareg-mode)
 (&quot;*Help*&quot; help-mode)
 (&quot;*Messages*&quot; messages-buffer-mode)
 (&quot;sbet.ml&quot; tuareg-mode)
 (&quot; *Minibuf-0*&quot; minibuffer-inactive-mode)
 (&quot;test.el&quot; emacs-lisp-mode)
 ...
</code></pre>
<h3 id="get-buffer-contents--selection--line">Get Buffer Contents / Selection / Line</h3>
<p><strong>Get Buffer Content as String</strong></p>
<pre><code>ELISP&gt; (defun buffer-content (name)
         (with-current-buffer name
           (buffer-substring-no-properties (point-min) (point-max))))
buffer-content
ELISP&gt;

ELISP&gt; (buffer-content &quot;test3.ml&quot;)
&quot;\n\nlet rec prodlist = function \n    | [] ... &quot;
</code></pre>
<p><strong>Get Selected text in current buffer as string</strong></p>
<pre><code>(defun get-selection ()
  &quot;Get the text selected in current buffer as string&quot;
  (interactive)
  (buffer-substring-no-properties (region-beginning) (region-end))
  )
</code></pre>
<p><strong>Get current line in current buffer</strong></p>
<pre><code>(defun get-current-line ()
  (interactive)
  &quot;Get current line, where the cursor lies in the current buffer&quot;
  (replace-regexp-in-string &quot;[\n|\s\t]+$&quot; &quot;&quot; (thing-at-point 'line t))
  )
</code></pre>
<h3 id="search-and-replace-in-the-entire-buffer">Search and Replace in the entire Buffer</h3>
<pre><code>(defun replace-regexp-entire-buffer (pattern replacement)
  &quot;Perform regular-expression replacement throughout buffer.&quot;
  (interactive
   (let ((args (query-replace-read-args &quot;Replace&quot; t)))
     (setcdr (cdr args) nil)    ; remove third value returned from query---args
     args))
  (save-excursion
    (goto-char (point-min))
    (while (re-search-forward pattern nil t)
      (replace-match replacement))))
</code></pre>
<h2 id="point-region-line-and-buffer">Point, Region, Line and Buffer</h2>
<h3 id="point">Point</h3>
<p><strong>Point</strong></p>
<table>
<colgroup>
<col  class="org-left">
<col  class="org-left">
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Function</th>
<th scope="col" class="org-left">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">(point)</td>
<td class="org-left">Current cursor position</td>
</tr>
<tr>
<td class="org-left">(point-min)</td>
<td class="org-left">Minimum cursor position in current buffer. (always returns 1)</td>
</tr>
<tr>
<td class="org-left">(point-max)</td>
<td class="org-left">Maximum cursor position in current buffer.</td>
</tr>
<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
</tr>
<tr>
<td class="org-left">(line-beginning-position)</td>
<td class="org-left">Point of the beginning of current line.</td>
</tr>
<tr>
<td class="org-left">(line-end-position)</td>
<td class="org-left">Point of the end of current line.</td>
</tr>
<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
</tr>
<tr>
<td class="org-left">(region-beginning)</td>
<td class="org-left">Position of the beginning current region (selected text).</td>
</tr>
<tr>
<td class="org-left">(region-end)</td>
<td class="org-left">Position of the end current region.</td>
</tr>
<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
</tr>
<tr>
<td class="org-left">(bounds-of-thing-at-point <thing>)</td>
<td class="org-left">Returns the cons pair '(beginning . end) position of thing at point.</td>
</tr>
</tbody>
</table>
<p><strong>Point Interface Functions</strong></p>
<table>
<colgroup>
<col  class="org-left">
<col  class="org-left">
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Function</th>
<th scope="col" class="org-left">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">(goto-char <point>)</td>
<td class="org-left">Move the cursor to a given point.</td>
</tr>
<tr>
<td class="org-left">(insert <string>)</td>
<td class="org-left">Insert text at current point.</td>
</tr>
<tr>
<td class="org-left">(buffer-substring [pmin] [pmax])</td>
<td class="org-left">Returns the text with properties between the points <pmin> and <pmax>.</td>
</tr>
<tr>
<td class="org-left">(buffer-substring-no-properties [pmin] pmax])</td>
<td class="org-left">Returns the text without properties between the points.</td>
</tr>
<tr>
<td class="org-left">(delete-region [pmin] [pmax])</td>
<td class="org-left">Deletes the text between <pmin> and <pmax>.</td>
</tr>
</tbody>
</table>
<pre><code>&gt; (point)
99696

&gt; (point-min)
1


&gt; (point-max)
185623

&gt;  (line-beginning-position)
99774

&gt;  (line-end-position)
99804

&gt; (buffer-substring-no-properties
   (line-beginning-position)
   (line-end-position))

(defun delete-line ()
  (interactive)
  (delete-region  (line-beginning-position)  (line-end-position)))

(defun delete-region ()
  (interactive)
  (delete-region  (region-beginning) (region-end)))

(defun insert-end-of-buffer ()
  (interactive)

  ;; Save Current Cursor Position
  ;; and go back to initial positon when
  ;; finish this block
  (save-excursion
    (goto-char (point-max)) ;;; Go to end of buffer
    (insert &quot;Testing insert end of buffer&quot;)
    ))
</code></pre>
<h3 id="thing-at-point-api">Thing at Point API</h3>
<p>???</p>
<h2 id="message--output">Message / Output</h2>
<pre><code>(message &quot;Hello world&quot;)
(message-box &quot;Time for a break.\nDrink some coffee&quot;)
</code></pre>
<h2 id="files-directories-and-path">Files, Directories and Path</h2>
<h3 id="basic-functions">Basic Functions</h3>
<pre><code>;; Get and Set current directory

ELISP&gt; (pwd)
&quot;Directory /home/tux/tmp/&quot;

ELISP&gt; (cd &quot;/etc/&quot;)
&quot;/etc/&quot;

ELISP&gt; (pwd)
&quot;Directory /etc/&quot;
ELISP&gt;


ELISP&gt; (file-name-directory &quot;/etc/hosts&quot;)
&quot;/etc/&quot;

;; Expand File Name
;;
ELISP&gt; (expand-file-name &quot;~/&quot;)
&quot;/home/tux/&quot;
ELISP&gt; (expand-file-name &quot;.&quot;)
&quot;/home/tux/tmp&quot;
ELISP&gt; (expand-file-name &quot;..&quot;)
&quot;/home/tux&quot;
ELISP&gt;


;;;;; Create a Directory
;;;
ELISP&gt; (mkdir &quot;dummy&quot;)
nil
ELISP&gt; (mkdir &quot;dummy&quot;)
** Eval error **  File exists: /home/tux/dummy
ELISP&gt;

;;; List Directory
;;;;
;;;
ELISP&gt; (directory-files &quot;/home/tux/PycharmProjects/Haskell/&quot;)
(&quot;.&quot; &quot;..&quot; &quot;.git&quot; &quot;.gitignore&quot; &quot;.idea&quot; &quot;LICENSE&quot; &quot;Make&quot; &quot;Makefile&quot;
 &quot;README.back.md&quot; &quot;README.html&quot; &quot;README.md&quot; &quot;Test.html&quot; &quot;build.sh&quot; &quot;clean.sh&quot;
 &quot;codes&quot; &quot;dict.sh&quot; &quot;haskell&quot; &quot;ocaml&quot; &quot;papers&quot; &quot;tags&quot; &quot;tmp&quot;)
</code></pre>
<h3 id="file-name-components">File Name Components</h3>
<pre><code>ELISP&gt; (file-name-directory &quot;/usr/bin/env&quot;)
&quot;/usr/bin/&quot;
ELISP&gt;

ELISP&gt; (file-name-nondirectory &quot;/usr/bin/env&quot;)
&quot;env&quot;
ELISP&gt;


ELISP&gt; (file-name-base &quot;/home/foo/zoo1.c&quot;)
&quot;zoo1&quot;
ELISP&gt; (file-name-base &quot;/home/foo/zoo1.c.back&quot;)
&quot;zoo1.c&quot;
</code></pre>
<h3 id="read--write-file-to-a-string">Read / Write file to a string</h3>
<p><strong>Read File</strong></p>
<pre><code>ELISP&gt; (defun file-contents (filename)
  (interactive &quot;fFind file: &quot;)
  (with-temp-buffer
    (insert-file-contents filename) ;; å…ˆå°†æ–‡ä»¶å†…å®¹æ’å…¥ä¸´æ—¶bufferï¼Œå†è¯»å–å†…å®¹
    (buffer-substring-no-properties (point-min) (point-max))))

ELISP&gt; (file-contents &quot;/proc/filesystems&quot;)
&quot;nodev  sysfs\nnodev    rootfs\nnodev   ramfs\nnodev
bdev\nnodev proc\nnodev cgroup\nnode ...
</code></pre>
<p><strong>Write to File</strong></p>
<pre><code>ELISP&gt; (append-to-file &quot;hello world&quot; nil &quot;/tmp/hello.txt&quot;)
nil

ELISP&gt; (file-contents &quot;/tmp/hello.txt&quot;)
&quot;hello world&quot;
ELISP&gt;
</code></pre>
<h2 id="window-functions">Window Functions</h2>
<h3 id="basic-window-functions">Basic Window Functions</h3>
<pre><code>(split-window-horizontally)
(split-window-vertically)
(delete-other-windows)
(switch-to-buffer-other-window &quot;init.el&quot;)
(delete-window)
(make-frame)
(frame-list)
(delete-frame)
</code></pre>
<h3 id="manipulate-buffer-in-another-window">Manipulate Buffer in Another Window</h3>
<p><a href="http://caiorss.github.io/Emacs-Elisp-Programming/Elisp_Programming.html#sec-3-9-2">http://caiorss.github.io/Emacs-Elisp-Programming/Elisp_Programming.html#sec-3-9-2</a></p>
<h3 id="window-configuration">Window Configuration</h3>
<pre><code>(current-window-configuration)
(setq w (current-window-configuration))
w
(set-window-configuration w)

;; Screen Resolution

ELISP&gt; (x-display-pixel-width)
1366

ELISP&gt; (x-display-pixel-height)
768
ELISP&gt;
ELISP&gt;

;; Resize and Set Emacs Windows position
;;
;; From: http://uce.uniovi.es/tips/Emacs/mydotemacs.html#sec-41
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

ELISP&gt; (defun resize-frame ()
  &quot;Set size&quot;
  (interactive)
  (set-frame-width (selected-frame) 100)
  (set-frame-height (selected-frame) 28)
  (set-frame-position (selected-frame) 0 1))
resize-frame
ELISP&gt;

ELISP&gt; (resize-frame)
t
ELISP&gt;
</code></pre>
<h2 id="os-interface">OS Interface</h2>
<h3 id="find-the-current-operating-system">Find the current operating system</h3>
<table>
<colgroup>
<col  class="org-left">
<col  class="org-left">
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Value</th>
<th scope="col" class="org-left">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">gnu</td>
<td class="org-left">GNU Hurd system.</td>
</tr>
<tr>
<td class="org-left">gnu/linux</td>
<td class="org-left">GNU/Linux system.</td>
</tr>
<tr>
<td class="org-left">gnu/kfreebsd</td>
<td class="org-left">GNU system with a FreeBSD kernel.</td>
</tr>
<tr>
<td class="org-left">darwin</td>
<td class="org-left">Darwin (GNU-Darwin, Mac OS X)</td>
</tr>
<tr>
<td class="org-left">ms-dos</td>
<td class="org-left">MS-DOS application.</td>
</tr>
<tr>
<td class="org-left">windows-nt</td>
<td class="org-left">native W32 application.</td>
</tr>
<tr>
<td class="org-left">cygwin</td>
<td class="org-left">compiled using the Cygwin library</td>
</tr>
</tbody>
</table>
<pre><code>system-type
system-configuration
</code></pre>
<h3 id="date-and-time">Date and Time</h3>
<pre><code>(current-time)
(insert (format-time-string &quot;%Y-%m-%d&quot;)) ;; 2019-12-15
(insert (format-time-string &quot;%H:%M:%S&quot;)) ;; 16:11:04
(format-time-string &quot;%d/%m/%Y %H:%M:%S&quot; (current-time))
</code></pre>
<h3 id="call-external-commands-or-apps">Call External Commands or Apps</h3>
<pre><code>(call-process &quot;mpd&quot;)
(shell-command-to-string &quot;pwd&quot;)
</code></pre>
<h3 id="environment-variables">Environment Variables</h3>
<pre><code>(getenv &quot;PATH&quot;)
(split-string (getenv &quot;PATH&quot;) &quot;:&quot;)
(dolist (e (split-string  (getenv &quot;PATH&quot;) &quot;:&quot;)) (princ (format &quot;%s\n&quot; e)))
exec-path
(getenv &quot;HOME&quot;)
(setenv &quot;JAVA_HOME&quot; &quot;/usr/local/java&quot;)

system-type
(eq system-type 'gnu/linux)()
(dolist (e process-environment) (princ (format &quot;%s\n&quot; e)))
</code></pre>
<h3 id="process-management">Process Management</h3>
<pre><code>(process-list)
(get-process &quot;merlin&quot;)
(mapcar 'process-name (process-list))

;;;; Buffer Process
(process-command (get-process &quot;vterm&quot;))
(process-id (get-process &quot;vterm&quot;))
(process-buffer (get-process &quot;vterm&quot;))
(buffer-name (process-buffer (get-process &quot;vterm&quot;)))
(mapcar (lambda (p) (buffer-name (process-buffer p))) (process-list))
(display-buffer (process-buffer (get-process &quot;vterm&quot;)))

;;;; Start Asyncronous Process
;;  Start the process named py, with the buffer named pybff
;;  using the command python, /usr/bin/python (on linux)
(start-process &quot;py&quot; &quot;pybff&quot; &quot;python&quot;)
;; End the process named py
(process-send-eof &quot;py&quot;)

(process-send-string &quot;py&quot; &quot;print 'Hello world'\n&quot;)

;;;; Get Multiple Fields

(mapcar
 (lambda (p)(list
             p
             (process-name p)
             (process-command p)
             (list (process-buffer p) (buffer-name (process-buffer p)))
             (process-id p)
             (process-status p)
             ))
 (process-list))
</code></pre>
<h2 id="interfaces">Interfaces</h2>
<h3 id="creating-quick-access-menu">Creating Quick Access Menu</h3>
<pre><code>(require 'easymenu)

(easy-menu-define djcb-menu global-map &quot;Utils&quot;
  '(&quot;Utils&quot;
    (&quot;Shells&quot; ;; submenu
     [&quot;Ielm   - Emacs Lisp Shell&quot;       (ielm)]
     [&quot;Eshell - Emacs Buitin Shell&quot;    (eshell)]
     [&quot;Native Shell &quot;                  (shell)]
     [&quot;---------------------&quot; nil]
     [&quot;Edit .bashrc&quot; (find-file  &quot;~/.bashrc&quot;)]
     [&quot;Edit .profile&quot; (find-file &quot;~/.profile&quot;)]
     [&quot;Edit .Xresources&quot; (find-file &quot;~/.Xresources&quot;)]
     [&quot;Edit .xsessin&quot;    (find-file &quot;~/.xsession&quot;)]
     [&quot;See all GNU MAN pages&quot; ( info)]
     [&quot;See a specific Man Page&quot; (woman)]

     );; End of shells menu

    (&quot;Emacs /Elisp&quot;  ;; submenu

     [&quot;Ielm   - Emacs Lisp Shell&quot;  (ielm)]
     [&quot;Eval buffer&quot;   (eval-buffer) ]
     [&quot;---------------------&quot; nil]

     [&quot;Edit  init.el&quot; (find-file  user-init-file)]
     [&quot;Reload init.el&quot; (load-file user-init-file)]
     [&quot;Open .emac.d dir&quot; (find-file &quot;~/.emacs.d&quot;)]
     [&quot;List packages&quot;     (list-packages)]
     [&quot;Install package&quot;   (package-install)]

     ) ;; End of Emacs / Elisp submenu
    )) ;; End of Custom Menu
</code></pre>
<h3 id="add-icons-to-toolbar">Add Icons to toolbar</h3>
<p><a href="http://caiorss.github.io/Emacs-Elisp-Programming/Elisp_Programming.html#sec-3-11-2">http://caiorss.github.io/Emacs-Elisp-Programming/Elisp_Programming.html#sec-3-11-2</a></p>
<h2 id="timer">Timer</h2>
<h3 id="run-with-timer">run-with-timer</h3>
<pre><code>;;; (run-with-timer SECS REPEAT FUNCTION &amp;rest ARGS)
(run-with-timer 5 nil
                (lambda () (message-box &quot;happy hacking emacs!&quot;)))

(defun cofee-wait ()
  (interactive)
  (let ((minutes 3))
    (run-with-timer (* 60 minutes)  nil
                    (lambda () (message-box &quot;Coffee done&quot;))
                    )
    (message &quot;Waiting for the cofee&quot;)
    ))
</code></pre>
<h2 id="emacs-modes">Emacs Modes</h2>
<h3 id="mode-association-with-files">Mode Association with Files</h3>
<pre><code>;; åˆ—å‡ºæ‰€æœ‰å’Œæ‹“å±•åç›¸å…³çš„mode
auto-mode-alist
;; åˆ—å‡ºä¸ä¸€ä¸ªmodeç›¸å…³çš„æ‰€æœ‰æ‹“å±•å
(remove-if-not
 (lambda (al) (equal (cdr al) 'web-mode)) auto-mode-alist)
;; ä¸ºä¸€ä¸ªmodeå…³è”æ‹“å±•å
(add-to-list 'auto-mode-alist '(&quot;\\.markdown\\'&quot; . markdown-mode))
</code></pre>
<h3 id="lisp-routines-to-introspect-modes">Lisp Routines to introspect modes??</h3>
<pre><code>(defun show-doc (function)
  (princ (documentation function)))

(defun mode/show ()
  &quot;  Returns all modes associated with files

     To query the file extesions associated with a mode
     use:
         &gt; (mode/ftypes 'markdown-mode)

     for example.
  &quot;
  (dolist (m (remove-if #'listp
                        (mapcar #'cdr auto-mode-alist))) (print m)))

(defun mode/ftypes (mode)
  &quot;
  Get all file extension associated with a mode.

  Usage:

  ELISP&gt; (get-mode-ftypes 'markdown-mode)
  ((\&quot;\\.md\\'\&quot; . markdown-mode)
  (\&quot;\\.text\\'\&quot; . markdown-mode)
  (\&quot;\\.markdown\\'\&quot; . markdown-mode)

  &quot;
  (remove-if-not
   (lambda (al)
     (equal (cdr al) mode))
   auto-mode-alist))

ELISP&gt; (mode/ftypes 'clojure-mode)
((&quot;\\(?:build\\|profile\\)\\.boot\\'&quot; . clojure-mode)
 (&quot;\\.\\(clj\\|dtm\\|edn\\)\\'&quot; . clojure-mode))

ELISP&gt; (mode/ftypes 'scheme-mode)
((&quot;\\.\\(scm\\|stk\\|ss\\|sch\\)\\'&quot; . scheme-mode)
 (&quot;\\.scm\\.[0-9]*\\'&quot; . scheme-mode)
 (&quot;\\.oak\\'&quot; . scheme-mode))

ELISP&gt; (show-doc #'mode/ftypes)

Get all file extension associated with a mode.

Usage:

ELISP&gt; (get-mode-ftypes 'markdown-mode)
((&quot;\.md\'&quot; . markdown-mode)
 (&quot;\.text\'&quot; . markdown-mode)
 (&quot;\.markdown\'&quot; . markdown-mode))
</code></pre>
<h3 id="mode-specific-key-bindings">Mode Specific Key Bindings</h3>
<pre><code>(define-key emacs-lisp-mode-map (kbd &quot;&lt;f5&gt;&quot;)
  (lambda () (interactive) (message &quot;Hello world&quot;)))
(add-hook 'lisp-interaction-mode-hook 'turn-on-eldoc-mode)
</code></pre>
<h2 id="special-variables">Special Variables</h2>
<pre><code>emacs-major-version
load-path
window-system
system-type
system-configuration
shell-file-name
user-full-name
user-mail-address
user-init-file
user-emacs-directory
exec-directory
</code></pre>
<h2 id="network">Network</h2>
<p><a href="http://caiorss.github.io/Emacs-Elisp-Programming/Elisp_Programming.html#sec-3-15">http://caiorss.github.io/Emacs-Elisp-Programming/Elisp_Programming.html#sec-3-15</a></p>
<h1 id="æ­£åˆ™è¡¨è¾¾å¼">æ­£åˆ™è¡¨è¾¾å¼</h1>
<h2 id="emacs-regex">Emacs Regex</h2>
<p><strong>Special characters</strong></p>
<table>
<colgroup>
<col  class="org-left">
<col  class="org-left">
</colgroup>
<tbody>
<tr>
<td class="org-left">.</td>
<td class="org-left">any character (but newline)</td>
</tr>
<tr>
<td class="org-left">\*</td>
<td class="org-left">previous character or group, repeated 0 or more time</td>
</tr>
<tr>
<td class="org-left">+</td>
<td class="org-left">previous character or group, repeated 1 or more time</td>
</tr>
<tr>
<td class="org-left">?</td>
<td class="org-left">previous character or group, repeated 0 or 1 time</td>
</tr>
<tr>
<td class="org-left">^</td>
<td class="org-left">start of line</td>
</tr>
<tr>
<td class="org-left">$</td>
<td class="org-left">end of line</td>
</tr>
<tr>
<td class="org-left">[â€¦]</td>
<td class="org-left">any character between brackets</td>
</tr>
<tr>
<td class="org-left">[^..]</td>
<td class="org-left">any character not in the brackets</td>
</tr>
<tr>
<td class="org-left">[a-z]</td>
<td class="org-left">any character between a and z</td>
</tr>
<tr>
<td class="org-left">\\</td>
<td class="org-left">prevents interpretation of following special char</td>
</tr>
<tr>
<td class="org-left">\\</td>
<td class="org-left">or</td>
</tr>
<tr>
<td class="org-left">\w</td>
<td class="org-left">word constituent</td>
</tr>
<tr>
<td class="org-left">\b</td>
<td class="org-left">word boundary</td>
</tr>
<tr>
<td class="org-left">\sc</td>
<td class="org-left">character with c syntax (e.g. \s- for whitespace char)</td>
</tr>
<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">start\end of group</td>
</tr>
<tr>
<td class="org-left">\\<</td>
<td class="org-left">\\> start\end of word</td>
</tr>
<tr>
<td class="org-left">\\\`</td>
<td class="org-left">\\' start\end of buffer</td>
</tr>
<tr>
<td class="org-left">\\1</td>
<td class="org-left">string matched by the first group</td>
</tr>
<tr>
<td class="org-left">\n</td>
<td class="org-left">string matched by the nth group</td>
</tr>
<tr>
<td class="org-left">\\{3\\}</td>
<td class="org-left">previous character or group, repeated 3 times</td>
</tr>
<tr>
<td class="org-left">\\{3,\\}</td>
<td class="org-left">previous character or group, repeated 3 or more times</td>
</tr>
<tr>
<td class="org-left">\\{3,6\\}</td>
<td class="org-left">previous character or group, repeated 3 to 6 times</td>
</tr>
</tbody>
</table>
<p><strong>POSIX Character classes</strong></p>
<table>
<colgroup>
<col  class="org-left">
<col  class="org-left">
</colgroup>
<tbody>
<tr>
<td class="org-left">[:digit:]</td>
<td class="org-left">digit, same as [0-9]</td>
</tr>
<tr>
<td class="org-left">[:upper:]</td>
<td class="org-left">letter in uppercase</td>
</tr>
<tr>
<td class="org-left">[:space:]</td>
<td class="org-left">whitespace character, as defined by the syntax table</td>
</tr>
<tr>
<td class="org-left">[:xdigit:]</td>
<td class="org-left">hexadecimal digit</td>
</tr>
<tr>
<td class="org-left">[:cntrl:]</td>
<td class="org-left">control character</td>
</tr>
<tr>
<td class="org-left">[:ascii:]</td>
<td class="org-left">ascii character</td>
</tr>
</tbody>
</table>
<p><strong>Syntax Classes</strong></p>
<table>
<colgroup>
<col  class="org-left">
<col  class="org-left">
<col  class="org-left">
<col  class="org-left">
</colgroup>
<tbody>
<tr>
<td class="org-left">\s-</td>
<td class="org-left">whitespace character</td>
<td class="org-left">\s/</td>
<td class="org-left">character quote character</td>
</tr>
<tr>
<td class="org-left">\sw</td>
<td class="org-left">word constituent</td>
<td class="org-left">\s$</td>
<td class="org-left">paired delimiter</td>
</tr>
<tr>
<td class="org-left">\s\_</td>
<td class="org-left">symbol constituent</td>
<td class="org-left">\s'</td>
<td class="org-left">expression prefix</td>
</tr>
<tr>
<td class="org-left">\s.</td>
<td class="org-left">punctuation character</td>
<td class="org-left">\s<</td>
<td class="org-left">comment starter</td>
</tr>
<tr>
<td class="org-left">\s(</td>
<td class="org-left">open delimiter character</td>
<td class="org-left">\s></td>
<td class="org-left">comment starter</td>
</tr>
<tr>
<td class="org-left">\s)</td>
<td class="org-left">close delimiter character</td>
<td class="org-left">\s!</td>
<td class="org-left">generic comment delimiter</td>
</tr>
<tr>
<td class="org-left">\s"</td>
<td class="org-left">string quote character</td>
<td class="org-left">\s</td>
<td class="org-left">generic string delimiter</td>
</tr>
<tr>
<td class="org-left">\s\\</td>
<td class="org-left">escape character</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
</tr>
</tbody>
</table>
<p><strong>Emacs X Perl Regex</strong></p>
<table>
<colgroup>
<col  class="org-left">
<col  class="org-left">
<col  class="org-left">
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Emacs Regex</th>
<th scope="col" class="org-left">Perl Regex</th>
<th scope="col" class="org-left">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">( )</td>
<td class="org-left">Capture group</td>
</tr>
<tr>
<td class="org-left">\\{ \\}</td>
<td class="org-left">{ }</td>
<td class="org-left">&#xa0;</td>
</tr>
<tr>
<td class="org-left">\s-</td>
<td class="org-left">\s</td>
<td class="org-left">White space</td>
</tr>
<tr>
<td class="org-left">\\1, \\2, \\3, \\4</td>
<td class="org-left">$1, $2, $3</td>
<td class="org-left">Result of capture: search, replace.</td>
</tr>
<tr>
<td class="org-left">[ ]</td>
<td class="org-left">[ ]</td>
<td class="org-left">Character class</td>
</tr>
<tr>
<td class="org-left">[0-9] or [:digit:]</td>
<td class="org-left">\d</td>
<td class="org-left">Digit from 0 to 9</td>
</tr>
<tr>
<td class="org-left">\b</td>
<td class="org-left">\b</td>
<td class="org-left">Word boundary</td>
</tr>
<tr>
<td class="org-left">\w</td>
<td class="org-left">\w</td>
<td class="org-left">Word character</td>
</tr>
</tbody>
</table>
<h2 id="regex-commands">Regex Commands</h2>
<table>
<colgroup>
<col  class="org-left">
<col  class="org-left">
</colgroup>
<tbody>
<tr>
<td class="org-left">C-M-s</td>
<td class="org-left">incremental forward search matching regexp</td>
</tr>
<tr>
<td class="org-left">C-M-r</td>
<td class="org-left">incremental backward search matching regexp</td>
</tr>
</tbody>
</table>
<p><strong>Buffer Commands</strong></p>
<table>
<colgroup>
<col  class="org-left">
<col  class="org-left">
</colgroup>
<tbody>
<tr>
<td class="org-left">M-x replace-regexp</td>
<td class="org-left">replace string matching regexp</td>
</tr>
<tr>
<td class="org-left">M-x query-replace-regexp</td>
<td class="org-left">same, but query before each replacement</td>
</tr>
<tr>
<td class="org-left">M-x align-regexp</td>
<td class="org-left">align, using strings matching regexp as delimiters</td>
</tr>
<tr>
<td class="org-left">M-x highlight-regexp</td>
<td class="org-left">highlight strings matching regexp</td>
</tr>
<tr>
<td class="org-left">M-x grep</td>
<td class="org-left">call unix grep command and put result in a buffer</td>
</tr>
<tr>
<td class="org-left">M-x lgrep</td>
<td class="org-left">user-friendly interface to the grep command</td>
</tr>
<tr>
<td class="org-left">M-x rgrep</td>
<td class="org-left">recursive grep</td>
</tr>
<tr>
<td class="org-left">M-x dired-do-copy-regexp</td>
<td class="org-left">copy files with names matching regexp</td>
</tr>
<tr>
<td class="org-left">M-x dired-do-rename-regexp</td>
<td class="org-left">rename files matching regexp</td>
</tr>
<tr>
<td class="org-left">M-x find-grep-dired</td>
<td class="org-left">display files containing matches for regexp with Dired</td>
</tr>
</tbody>
</table>
<p><strong>Line Commands</strong></p>
<table>
<colgroup>
<col  class="org-left">
<col  class="org-left">
<col  class="org-left">
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Command (M-x command)</th>
<th scope="col" class="org-left">Alias</th>
<th scope="col" class="org-left">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">keep-lines</td>
<td class="org-left">delete-non-matching-lines</td>
<td class="org-left">Delete all lines except those containing matches</td>
</tr>
<tr>
<td class="org-left">flush-lines</td>
<td class="org-left">delete-matching-lines</td>
<td class="org-left">Delete lines containing matches</td>
</tr>
<tr>
<td class="org-left">highlight-lines-matching-regexp</td>
<td class="org-left">hi-lock-line-face-buffer</td>
<td class="org-left">Highlight lines matching regexp</td>
</tr>
<tr>
<td class="org-left">occur</td>
<td class="org-left">list-matching-lines</td>
<td class="org-left">Show lines containing a match</td>
</tr>
<tr>
<td class="org-left">multi-occur</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">Show lines in all buffers containing a match</td>
</tr>
<tr>
<td class="org-left">how-many</td>
<td class="org-left">count-matches</td>
<td class="org-left">Count the number of strings matching regexp</td>
</tr>
</tbody>
</table>
<h2 id="regex-functions">Regex Functions</h2>
<h3 id="match-string">match-string</h3>
<h3 id="match-end">match-end</h3>
<h3 id="match-beginning">match-beginning</h3>
<h3 id="re-search">re-search</h3>
<h3 id="re-search-forward">re-search-forward</h3>
<h3 id="replace-string-in-regexp">replace-string-in-regexp</h3>
<h3 id="replace-string">replace-string</h3>
<h2 id="build-regex-interactively">Build regex interactively</h2>
<p>M-x re-builder</p>
<p>M-x query-replace-regexp</p>
<h2 id="emacs-regex-rx-notation">Emacs Regex rx-notation</h2>
<pre><code>(require 'rx)

;;  (rx &lt;patterns&gt;)

ELISP&gt; (rx digit)
&quot;[[:digit:]]&quot;

ELISP&gt; (rx-to-string '(or &quot;foo&quot; &quot;bar&quot;))
&quot;\\(?:\\(?:bar\\|foo\\)\\)&quot;
</code></pre>
<table>
<colgroup>
<col  class="org-left">
<col  class="org-left">
<col  class="org-left">
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Description</th>
<th scope="col" class="org-left">rx notation</th>
<th scope="col" class="org-left">Emacs regex</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">Beginning of Line</td>
<td class="org-left">bol</td>
<td class="org-left">^</td>
</tr>
<tr>
<td class="org-left">End of Line</td>
<td class="org-left">eol</td>
<td class="org-left">$</td>
</tr>
<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
</tr>
<tr>
<td class="org-left">Begining of String</td>
<td class="org-left">bos</td>
<td class="org-left">\\\\\`</td>
</tr>
<tr>
<td class="org-left">End of String</td>
<td class="org-left">eos</td>
<td class="org-left">`\\'`</td>
</tr>
<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
</tr>
<tr>
<td class="org-left">Beginning of Word</td>
<td class="org-left">bow</td>
<td class="org-left">\\\\<</td>
</tr>
<tr>
<td class="org-left">End of Word</td>
<td class="org-left">eow</td>
<td class="org-left">\\\\></td>
</tr>
<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
</tr>
<tr>
<td class="org-left">Digit 0 to 9</td>
<td class="org-left">digit</td>
<td class="org-left">\lbr\lbr:digit:\rbr\rbr</td>
</tr>
<tr>
<td class="org-left">Hexadecimal digit</td>
<td class="org-left">hex</td>
<td class="org-left">\lbr\lbr:xdigit:\rbr\rbr</td>
</tr>
<tr>
<td class="org-left">Match ascii character</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
</tr>
<tr>
<td class="org-left">Match anything lower case</td>
<td class="org-left">lower</td>
<td class="org-left">\lbr\lbr:lower:\rbr\rbr</td>
</tr>
<tr>
<td class="org-left">Match anything upper case</td>
<td class="org-left">upper</td>
<td class="org-left">\lbr\lbr:upper:\rbr\rbr</td>
</tr>
<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
</tr>
<tr>
<td class="org-left">word</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">\sw</td>
</tr>
</tbody>
</table>
<p><em>example</em></p>
<pre><code>ELISP&gt; (require 'rx)
rx

ELISP&gt; (rx (+ digit))
&quot;[[:digit:]]+&quot;

ELISP&gt; (rx digit (+ digit))
&quot;[[:digit:]][[:digit:]]+&quot;

ELISP&gt; (rx bol (+ digit) eol)
&quot;^[[:digit:]]+$&quot;

ELISP&gt; (rx (zero-or-more digit))
&quot;[[:digit:]]*&quot;

ELISP&gt; (rx (one-or-more digit))
&quot;[[:digit:]]+&quot;

ELISP&gt; (rx (or &quot;cat&quot; &quot;rat&quot; &quot;dog&quot;))
&quot;\\(?:cat\\|dog\\|rat\\)&quot;

;; (replace-regexp-in-string REGEXP REP STRING
;;      &amp;optional FIXEDCASE LITERAL SUBEXP START)

ELISP&gt; (replace-regexp-in-string
          (rx (or &quot;cat&quot; &quot;rat&quot; &quot;dog&quot;))
          &quot;&quot;
          &quot;cat cata rat rat dograt dog cat2334 23rat2&quot;)
&quot; a     2334 232&quot;

;; Replaces only in the beggining of line
;;
ELISP&gt;  (replace-regexp-in-string
          (rx bol (or &quot;cat&quot; &quot;rat&quot; &quot;dog&quot;))
          &quot;&quot;
          &quot;cat cata rat rat dograt dog cat2334 23rat2&quot;)
&quot; cata rat rat dograt dog cat2334 23rat2&quot;


ELISP&gt;  (replace-regexp-in-string
          (rx bow (or &quot;cat&quot; &quot;rat&quot; &quot;dog&quot;) eow)
          &quot;&quot;
          &quot;cat cata rat rat dograt dog cat2334 23rat2&quot;)
&quot; cata   dograt  cat2334 23rat2&quot;

ELISP&gt;  (rx bow (or &quot;cat&quot; &quot;rat&quot; &quot;dog&quot;) eow)
&quot;\\&lt;\\(?:cat\\|dog\\|rat\\)\\&gt;&quot;

;;  Removes all whitespaces
;;
ELISP&gt;  (replace-regexp-in-string
          (rx (* whitespace))
          &quot;&quot;
          &quot;cat cata rat rat dograt dog cat2334 23rat2&quot;)

&quot;catcataratratdogratdogcat233423rat&quot;

ELISP&gt;  (replace-regexp-in-string
          (rx (* whitespace))
          &quot;&quot;
          &quot;cat cata rat rat dograt dog cat2334 23rat2&quot;)

&quot;catcataratratdogratdogcat233423rat&quot;

;; Capture group
;;
ELISP&gt;  (replace-regexp-in-string
          (rx (submatch bow (or &quot;cat&quot; &quot;rat&quot; &quot;dog&quot;) eow))
          &quot;(\\1)&quot;
          &quot;cat cata rat rat dograt dog cat2334 23rat2&quot;)

&quot;(cat) cata (rat) (rat) dograt (dog) cat2334 23rat2&quot;

ELISP&gt; (rx (submatch bow (or &quot;cat&quot; &quot;rat&quot; &quot;dog&quot;) eow))
&quot;\\(\\&lt;\\(?:cat\\|dog\\|rat\\)\\&gt;\\)&quot;
</code></pre>
<h1 id="color-scheme">Color Scheme</h1>
<p><a href="http://caiorss.github.io/Emacs-Elisp-Programming/Elisp_Programming.html#sec-5">http://caiorss.github.io/Emacs-Elisp-Programming/Elisp_Programming.html#sec-5</a></p>
<h1 id="key-bindings">Key Bindings</h1>
<p><a href="http://caiorss.github.io/Emacs-Elisp-Programming/Elisp_Programming.html#sec-6">http://caiorss.github.io/Emacs-Elisp-Programming/Elisp_Programming.html#sec-6</a></p>

    </div>

    

    


    <div class="container-prevnext">
    <div><a href="https://geekinney.com/post/thinking-about-anxiety/">â† å…³äºç„¦è™‘</a></div>
    <div><a href="https://geekinney.com/post/reading-notes-of-getting-things-done-one/">ã€Šæå®šIã€‹ç¬”è®°  â†’</a></div>
</div>
</div>

        </div>
        <div id="footer"><div class="container-footer">
    
    <a href="" target="_blank">
        
        <span class="some">enter your icp or a interesting slogan...<span>
        
    </a>
    <a id="s" href="/secrets">&nbsp;</a>
</div></div>
    </body>
</html>
